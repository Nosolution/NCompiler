# Yacc: 另一个编译器的编译器

[原文来源](http://dinosaur.compilertools.net/yacc/index.html)

## 摘要

计算机程序输入通常具有某种结构；实际上，每个进行输入的计算机程序都可以认为是定义了它接受的一种"输入语言"。输入语言可能像编程语言一样复杂，也可能像数字序列一样简单。不幸的是，通常的输入工具是有限的，难以使用的，并且常常对于检查其输入的有效性不严格。

Yacc提供了一种通用工具，用于描述计算机程序的输入。 Yacc用户指定其输入的结构，以及在识别每个这样的结构时要调用的代码。 Yacc将这样的规范转换为处理输入过程的子例程。通常，由该子例程处理用户应用程序中的大多数控制流是方便且适当的。

Yacc产生的输入子例程调用用户提供的例程以返回下一个基本输入项。因此，用户可以使用各个输入字符或诸如名称和数字之类的高级结构来规定需要的输入。用户提供的例程还可以处理惯用的功能，例如注释和继续约定，其通常不符合简单的语法规范。

Yacc用可移植的C语言编写。接受的规范类别是一个非常通用的规范：具有明确的规则的LALR(1)语法。

除了用于C，APL，Pascal，RATFOR等的编译器外，Yacc还用于不太传统的语言，包括照排机语言，几种台式计算器语言，文档检索系统和Fortran调试系统。

## 0. 介绍

Yacc提供了一种用于在计算机程序的输入上施加结构的通用工具。 Yacc用户准备输入过程的规范；其中包括描述输入结构的规则，识别这些规则时要调用的代码以及执行基本输入的低级例程。然后，Yacc生成一个函数来控制输入过程。此函数称为解析器，它调用用户提供的低级输入例程(词法分析器)以从输入流中提取基本项(称为标记)。这些标记根据输入结构规则(称为语法规则)进行组织；当识别出这些规则之一时，将调用为此规则提供的用户代码，即一个动作；动作可以返回值并利用其他动作的值。
Yacc用C[1]的可移植方言编写，并且动作和输出子例程也在C中。此外，Yacc的许多语法约定都遵循C。

输入规范的核心是语法规则的集合。每个规则描述一个允许的结构并为其命名。例如，一种语法规则可能是

```text
        date  :  month_name  day  ','  year   ;
```

这里，date，month_name，day和year表示输入过程中感兴趣的结构；大概在其他地方定义了month_name，day和year。 逗号","用单引号引起来; 这意味着逗号将直接出现在输入中。 冒号和分号仅用作规则中的标点符号，在控制输入中没有任何意义。 因此，使用正确的定义，输入

```text
        July  4, 1776
 ```

可能符合上述规则。
输入过程的重要部分由词法分析器执行。该用户例程读取输入流，识别较低层的结构，并将这些token传递给解析器。由于历史原因，词法分析器识别的结构称为终结符，而解析器识别的结构称为非终结符。 为避免混淆，终端符号通常称为token。

在决定是否使用词法分析器或语法规则来识别结构时，还有很大的余地。 例如规则

```text
        month_name  :  'J' 'a' 'n'   ;
        month_name  :  'F' 'e' 'b'   ;

                 . . .

        month_name  :  'D' 'e' 'c'   ;
```

可能在以上示例中使用。 词法分析器仅需要识别单个字母，并且month_name将是一个非终结符。 这样的低级规则往往会浪费时间和空间，并且可能使规范变得复杂，超出了Yacc的处理能力。 通常，词法分析器会识别月份名称，并返回指示可以看到month_name的指示。 在这种情况下，month_name将是一个令牌。
诸如','之类的文字字符也必须通过词法分析器传递，并且也被视为标记。

规范文件非常灵活。 在上面的示例中添加规则非常容易

```text
        date  :  month '/' day '/' year   ;
```

允许

```text
        7 / 4 / 1776
```

作为以下的同义词

```text
        July 4, 1776
```

在大多数情况下，可以以最小的努力将这一新规则"滑入"工作系统，并且几乎没有破坏现有输入的危险。  
读取的输入可能不符合规范。从理论上讲，从左到右扫描可以尽早检测到这些输入错误。因此，不仅大大减少了使用不良输入数据进行读取和计算的机会，而且通常可以很快找到不良数据。作为输入规范的一部分提供的错误处理允许重新输入不良数据，或者在跳过不良数据后继续输入过程。

在某些情况下，给定一组规范时，Yacc无法生成解析器。例如，规范可能是自相矛盾的，或者它们可能需要比Yacc可用的识别机制更强大的识别机制。前者代表设计错误；后者通常可以通过使词法分析器更强大或重写某些语法规则来纠正后一种情况。虽然Yacc不能处理所有可能的规范，但其功能可与类似系统相比。此外，Yacc难以处理的结构人类也常常难以处理。一些用户报告说，为他们的输入制定有效的Yacc规范的准则揭示了程序开发早期的概念或设计错误。

Yacc的理论基础已在其他地方进行了描述。[2，3，4]Yacc已被广泛用于许多实际应用中，包括lint，[5]便携式C编译器[6]和排版数学系统。[7]

接下来的几节描述了编写Yacc规范的基本过程；第1节介绍了语法规则的准备，第2节介绍了与这些规则相关的用户提供的动作，第3节介绍了词法分析器。第4节介绍了解析器的操作。第5节讨论了为什么Yacc不能根据规范生成解析器的各种原因，以及如何处理。第6节介绍了一种用于处理算术表达式中的运算符优先级的简单机制。第7节讨论了错误检测和恢复。第8节讨论了Yacc生成的解析器的操作环境和特殊功能。第9节提出了一些建议，这些建议应改善规范的样式和效率。第10节讨论了一些高级主题，第11节给出了致谢。附录A有一个简短的示例，附录B给出了Yacc输入语法的摘要。附录C给出了使用Yacc的一些更高级功能的示例，最后，附录D描述了不再受积极支持的机制和语法，但提供了与旧版本Yacc的历史连续性。

## 1. 基本定义

名称指代token或非终结符。 Yacc要求这样声明token名称。 另外，由于在第3节中讨论的原因，通常希望将词法分析器作为规范文件的一部分。 包括其他程序也可能很有用。 因此，每个规范文件都由三个部分组成：声明，(语法)规则和程序。 这些部分用双百分数'%%'标记分隔。 (百分比'%'通常在Yacc规范中用作转义符。)

换句话说，完整的规范文件看起来像

```text
        declarations
        %%
        rules
        %%
        programs
```

声明部分可能为空。此外，如果省略了程序部分，则也可以省略第二%%标记。
因此，最小的合法Yacc规范是

```text
        %%
        rules
```

空格，制表符和换行符将被忽略，但它们可能不会出现在名称或多字符保留符号中。 无论名称合法，都可能出现注释； 它们包含在/*... */中，与C和PL/I中一样。

规则部分由一个或多个语法规则组成。 语法规则的形式为：

```text
        A  :  BODY  ;
```

A表示非终结符名称，而BODY表示零个或多个名称和文字的序列。 冒号和分号是Yacc标点符号。
名称可以是任意长度的，并且可以由字母，点'.'，下划线'_'和非首字母数字组成。 大写和小写字母是不同的。 语法规则正文中使用的名称可能表示标记或非终结符。

文字由单引号"'"内的字符组成。 与C中一样，反斜杠"\"是文字中的转义字符，并且所有C转义都可以识别。 从而

```text
        '\n'    newline
        '\r'    return
        '\"    single quote "'"
        '\\'    backslash "\"
        '\t'    tab
        '\b'    backspace
        '\f'    form feed
        '\xxx'  "xxx" in octal
```

由于多种技术原因，在语法规则中绝对不应使用NUL字符(\0或0)。
如果左部有多个语法规则，则可以使用竖线"|"来避免重写左部。 此外，可以将规则末尾的分号放在竖线之前。 因此，语法规则

```text
        A       :       B  C  D   ;
        A       :       E  F   ;
        A       :       G   ;
```

可以写成如下形式给Yacc

```text
        A       :       B  C  D
                |       E  F
                |       G
                ;
```

具有相同左侧的所有语法规则都可以在语法规则部分中同时出现，这是不必要的，尽管这使输入的可读性更高，并且更易于更改。
如果非终结符与空字符串匹配，则可以用明显的方式表示出来：

```text
        empty :   ;
```

必须声明代表token的名称； 这很简单地通过编写来完成

```text
        %token   name1  name2 . . .
```

在声明部分。(有关更多讨论，请参见第3、5和6节)。声明部分中未定义的每个名称都假定代表一个非终结符。 每个非终止符号必须出现在至少一个规则的左侧。
在所有非终止符号中，其中一个称为开始符号的特别重要。 解析器被设计用于识别开始符号。 因此，该符号表示语法规则所描述的最大，最通用的结构。 默认情况下，开始符号被视为“规则”部分中第一个语法规则的左侧。 使用%start关键字可以在声明部分中显式声明开始符号：

```text
        %start   symbol
```

解析器的输入结束由特殊标记(称为结束标记)发出信号。如果直到结束标记(但不包括结束标记)的标记形成与起始符号匹配的结构，则解析器函数将在看到结束标记后返回到其调用方；它接受了输入。如果在任何其他上下文中都可以看到该结束标记，此则为错误。

用户提供的词法分析器的工作是在适当时返回结束标记。 请参阅下面的第3节。 通常，终结符代表某种相当明显的I/O状态，例如"文件结束"或"记录结束"。

## 2. 动作

使用每个语法规则，用户可以将动作关联为每次在输入过程中识别规则时执行。 这些动作可以返回值，并且可以获得先前动作返回的值。 此外，如果需要，词法分析器可以返回token的值。

动作是任意的C语句，因此可以执行输入和输出，调用子程序以及更改外部向量和变量。 动作由一个或多个用大括号"{"和"}"括起来的语句指定。 例如，

```text
        A       :       '('  B  ')'
                                {       hello( 1, "abc" );  }
```

和

```text
        XXX     :       YYY  ZZZ
                                {       printf("a message\n");
                                        flag = 25;   }
```

是带有动作的语法规则。
为了便于操作与解析器之间的轻松通信，对操作语句进行了一些更改。 在这种情况下，符号"美元符号""$"用作向Yacc的信号。

要返回值，该操作通常将伪变量"$$"设置为某个值。 例如，不执行任何操作但返回值1的操作是

```text
                {  $$ = 1;  }
```

为了获得先前动作和词法分析器返回的值，该动作可以使用伪变量$1，$2，...。 。 。，指的是规则右侧各组件从左到右读取的值。 因此，如果规则是

```text
        A       :       B  C  D   ;
```

例如，然后$ 2具有C返回的值，而$ 3具有D返回的值。
作为更具体的示例，请考虑以下规则

```text
        expr    :       '('  expr  ')'   ;
```

该规则返回的值通常是括号中的expr的值。 这可以用

```text
        expr    :        '('  expr  ')'         {  $$ = $2 ;  }
```

默认情况下，规则的值是其中第一个元素的值($1)。 因此，形式的语法规则

```text
        A       :       B    ;
```

经常不需要采取明确的行动。
在上面的示例中，所有操作均位于其规则的末尾。 有时，希望在完全解析规则之前获得控制权。 Yacc允许在规则的中间和结尾写入动作。 假定此规则返回一个值，该值可以通过通常的机制通过其右侧的操作来访问。 反过来，它可以访问左侧符号返回的值。 因此，在规则

```text
        A       :       B
                                {  $$ = 1;  }
                        C
                                {   x = $2;   y = $3;  }
```

效果是将x设置为1，并将y设置为C返回的值。
Yacc实际上会通过制造新的非终止符号名称以及将该名称与空字符串匹配的新规则来处理不终止规则的动作。 内部动作是通过识别此附加规则触发的动作。 Yacc实际上将上面的示例视为已编写：

```text
        $ACT    :       /* empty */
                                {  $$ = 1;  }
                ;

        A       :       B  $ACT  C
                                {   x = $2;   y = $3;  }
```

在许多应用程序中，输出不是直接由操作完成的； 而是在内存中构造一个数据结构(例如解析树)，并在生成输出之前对其应用转换。 给定例程来构建和维护所需的树结构，解析树特别容易构建。 例如，假设有一个C函数节点，其编写方式为

```text
        node( L, n1, n2 )
```

创建一个带有标签L的节点，后代为n1和n2，并返回新创建节点的索引。 然后可以通过提供以下操作来构建分析树：

```text
        expr    :       expr  '+'  expr
                                {  $$ = node( '+', $1, $3 );  }
```

在规范中。
用户可以定义动作要使用的其他变量。 声明和定义可以出现在声明部分中，并用标记"%{"和"%}"括起来。 这些声明和定义具有全局范围，因此对于动作语句和词法分析器来说都是已知的。 例如，

```text
        %{   int variable = 0;   %}
```

可以放置在声明部分，使变量可用于所有操作。 Yacc解析器仅使用以"yy"开头的名称; 用户应避免使用此类名称。
在这些示例中，所有值都是整数：有关其他类型的值的讨论将在第10节中找到。

## 3. 词法分析

用户必须提供一个词法分析器以读取输入流，并将token(如果需要，可以使用值)传递给解析器。 词法分析器是一个称为yylex的整数函数。 该函数返回一个整数，即token号，表示读取的token的种类。 如果存在与该token关联的值，则应将其分配给外部变量yylval。

解析器和词法分析器必须就这些token号达成一致，以便它们之间进行通信。 这些数字可以由Yacc选择，也可以由用户选择。 无论哪种情况，C的"#define"机制都被用来允许词法分析器象征性地返回这些数字。 例如，假设在Yacc规范文件的声明部分中定义了token名称DIGIT。 词法分析器的相关部分可能如下所示：

```text
        yylex(){
                extern int yylval;
                int c;
                . . .
                c = getchar();
                . . .
                switch( c ) {
                        . . .
                case '0':
                case '1':
                  . . .
                case '9':
                        yylval = c-'0';
                        return( DIGIT );
                        . . .
                        }
                . . .
```

目的是返回令牌数字DIGIT和一个等于该数字的数值的值。如果将词法分析器代码放在规范文件的“程序”部分中，则标识符DIGIT将定义为与令牌DIGIT关联的令牌号。

这种机制导致清晰，易于修改的词法分析器。唯一的陷阱是需要避免使用语法中在C或解析器中保留或有效的任何令牌名称；例如，在编译词法分析器时，如果肯定会使用记号名称，则几乎可以肯定会造成严重的困难。令牌名称错误是为错误处理保留的，不应天真地使用(请参见第7节)。

如上所述，令牌号可以由Yacc或由用户选择。在默认情况下，数字由Yacc选择。文字字符的默认标记号是本地字符集中字符的数字值。其他名称将从257开始分配令牌编号。

要将令牌号分配给令牌(包括文字)，可以在声明部分的令牌名称或文字的首次出现后紧跟一个非负整数。该整数被视为名称或文字的令牌编号。该机制未定义的名称和文字保留其默认定义。所有令牌编号必须互不相同，这一点很重要。

出于历史原因，结尾标记必须具有令牌号0或负数。用户无法重新定义此令牌号；因此，所有词法分析器应准备在输入结束时返回0或负数作为令牌数。

Mike Lesk开发的Lex程序是构建词法分析器的一个非常有用的工具。[8]这些词法分析器旨在与Yacc解析器紧密协调地工作。这些词法分析器的规范使用正则表达式而不是语法规则。可以轻松地使用Lex来生成非常复杂的词法分析器，但是仍然存在某些语言(例如FORTRAN)不适合任何理论框架，并且其语言分析器必须手工制作。

## 4. 分析器是如何工作的

Yacc将规范文件转换为C程序，该程序根据给定的规范解析输入。从规范到解析器的算法很复杂，这里不再讨论(有关更多信息，请参见参考资料)。但是，解析器本身是相对简单的，并且尽管不是严格必需的，但了解其工作原理仍将使错误恢复和歧义的处理变得更加容易理解。

Yacc产生的解析器由带有堆栈的有限状态机组成。解析器还能够读取和记住下一个输入token(称为lookahead token)。当前状态始终是堆栈顶部的状态。有限状态机的状态被赋予小整数标签；最初，计算机处于状态0，堆栈仅包含状态0，并且未读取任何lookahead token。

机器只有四个可用的动作，称为移位，规约，接受和错误。解析器的移动如下进行：

1. 根据其当前状态，解析器确定是否需要lookahead token来决定应执行的操作；如果需要一个但没有，则调用yylex获取下一个标记。
2. 使用当前状态和提前标记，如果需要，解析器决定并执行下一步动作。这可能会导致状态被推入堆栈或从堆栈弹出，导致lookahead token被处理或单独保留。

shift操作是解析器执行的最常见操作。每当执行shift操作时，总会有一个lookahead token。例如，在状态56中，可能有一个动作：

```text
                IF      shift 34
```

也就是说，在状态56中，如果lookahead token是IF，则将当前状态(56)向下推入堆栈，状态34变为当前状态(位于堆栈顶部)。 提前标记已清除。
reduce动作可防止堆栈无限增长。 当解析器看到语法规则的右手侧并准备宣布已经看到该规则的一个实例时，可以用reduce动作代替右手侧。 可能有必要参考lookahead token来决定是否reduce，但通常不是。 实际上，默认操作(以'.'表示)通常是reduce操作。

归约动作与单个语法规则相关联。 语法规则也被赋予较小的整数，从而导致一些混乱。 该行动

```text
                .       reduce 18
```

指语法规则18，而动作

```text
                IF      shift 34
```

指状态34。
假设要简化的规则是A：x y z；

reduce动作取决于左手符号(在这种情况下为A)和右手符号的数目(在这种情况下为3)。为了reduce，首先从堆栈中弹出前三个状态(通常，弹出的状态数等于规则右侧的符号数)。实际上，这些状态是在识别x，y和z时放在堆栈上的状态，不再具有任何有用的目的。弹出这些状态后，将发现一个状态，该状态是解析器在开始处理规则之前所处的状态。使用此发现的状态以及规则左侧的符号，执行实际上是A移位的操作。获得一个新状态，将其压入堆栈，然后继续解析。但是，左手符号的处理与token的普通移位之间存在显着差异，因此，此动作称为goto动作。特别是，lookahead token将通过移位清除，并且不受goto影响。无论如何，未覆盖状态都包含一个条目，例如：

```text
                A       goto 20
```

使状态20被推入堆栈，并成为当前状态。
实际上，reduce操作在解析中"将时钟倒转"，将状态从堆栈中弹出以返回到第一次看到规则右侧的状态。然后，解析器的行为就像当时看到了左侧一样。如果规则的右侧为空，则不会从堆栈中弹出任何状态：未覆盖的状态实际上是当前状态。

reduce动作在处理用户提供的动作和值时也很重要。reduce规则时，将在调整堆栈之前执行随规则提供的代码。除了保存状态的堆栈外，另一个与之并行运行的堆栈还保存了从词法分析器和操作返回的值。发生移位时，将外部变量yylval复制到值堆栈上。从用户代码返回后，进行还原。完成goto操作后，将外部变量yyval复制到值堆栈上。伪变量$1，$2等引用值堆栈。

从概念上讲，其他两个解析器动作要简单得多。 accept动作表示已看到整个输入，并且符合规范。仅当lookahead token是结束标记时，此操作才会出现，并指示解析器已成功完成其工作。另一方面，错误操作表示解析器无法根据规范继续解析的位置。输入

它所看到的token以及lookahead token不能跟随任何会导致合法输入的内容。解析器报告错误，并尝试恢复情况并继续解析：错误恢复(与检测错误相对)将在第7节中介绍。

现在该看看例子了！考虑规范

```text
        %token  DING  DONG  DELL
        %%
        rhyme   :       sound  place
                ;
        sound   :       DING  DONG
                ;
        place   :       DELL
                ;
```

当使用-v选项调用Yacc时，将生成一个名为y.output的文件，其中包含解析器的可读描述。 与上述语法相对应的y.output文件(除去一些统计信息的末尾)是：

```text
        state 0
                $accept  :  _rhyme  $end

                DING  shift 3
                .  error

                rhyme  goto 1
                sound  goto 2

        state 1
                $accept  :   rhyme_$end

                $end  accept
                .  error

        state 2
                rhyme  :   sound_place

                DELL  shift 5
                .  error

                place   goto 4

        state 3
                sound   :   DING_DONG

                DONG  shift 6
                .  error

        state 4
                rhyme  :   sound  place_    (1)

                .   reduce  1

        state 5
                place  :   DELL_    (3)

                .   reduce  3

        state 6
                sound   :   DING  DONG_    (2)

                .   reduce  2
```

请注意，除了每个状态的动作之外，还描述了每个状态中正在处理的解析规则。 _字符用于指示每个规则中已看到的内容和尚未出现的内容。 假设输入为

```text
        DING  DONG  DELL
```

在处理此输入时，请遵循解析器的步骤。
最初，当前状态为状态0。解析器需要引用输入以决定状态0中可用的动作之间的关系，因此读取第一个令牌DING，从而成为lookahead token。 处于状态0的DING上的操作为"移位3"，因此将状态3压入堆栈，并清除lookahead token。 状态3变为当前状态。 读取下一个令牌DONG，成为lookahead token。 状态3中对令牌DONG的操作为"移位6"，因此状态6被压入堆栈，并且lookahead被清除。 堆栈现在包含0、3和6。在状态6中，即使不咨询lookahead，解析器也会根据规则2进行reduce。

```text
                sound  :   DING  DONG
```

该规则的右侧有两个符号，因此会从堆栈中弹出两个状态6和3，显示状态0。咨询状态0的描述，寻找声音的转到，

```text
                sound   goto 2
```

获得;因此状态2被推入堆栈，成为当前状态。
在状态2中，必须读取下一个标记DELL。动作是"shift 5"，因此将状态5压入堆栈，堆栈上现在有0、2和5，并且清除了lookahead token。在状态5中，唯一的操作是按照规则3进行减少。该状态在右侧有一个符号，因此弹出状态5，并显示状态2。处于状态2的goto处于规则3的左侧，即状态4。现在，堆栈包含0、2和4。在状态4中，唯一的动作是按规则1进行归约。右边，因此弹出顶部的两个状态，再次显示状态0。在状态0中，有一个goto on押韵，导致解析器进入状态1。在状态1中，输入被读取；在状态1中，输入被读取。将获得结束标记，在y.output文件中由"$ end"表示。看到结束标记后，状态1中的操作将接受并成功结束解析。

敦促读者考虑遇到诸如DING DONG DONG，DING DONG，DING DONG DELL DELL等不正确的字符串时解析器是如何工作的。花更多的时间在上面以及其他简单的示例上，当更多的问题出现时，这种报酬将得到补偿。复杂的环境。

## 5. 二义性和冲突

如果存在一些可以以两种或更多种不同方式构造的输入字符串，则语法规则集将不明确。 例如，语法规则

```text
        expr    :       expr  '-'  expr
```

这是表达以下事实的自然方法：形成算术表达式的一种方法是将另外两个表达式放在一起
它们之间带有减号。 不幸的是，该语法规则并未完全指定所有复杂输入的结构方式。 例如，如果输入是

```text
        expr  -  expr  -  expr
```

该规则允许将此输入构造为

```text
        (  expr  -  expr  )  -  expr
```

或像是

```text
        expr  -  (  expr  -  expr  )
```

(第一个称为左结合，第二个称为右结合)。

      Yacc在尝试构建时会检测到此类歧义
解析器。 考虑所面临的问题很有启发性
解析器在收到输入(例如)时

```text
        expr  -  expr  -  expr
```

解析器读取第二个expr时，它具有的输入
看过：

```text
        expr  -  expr
```

匹配上面的语法规则的右侧。 解析器可以通过应用此规则来reduce输入； 应用后规则; 输入将reduce为expr(规则的左侧)。然后，解析器将读取输入的最后一部分：

```text
        -  expr
```

并再次reduce。 这样做的效果是采用左结合的解释。或者，当解析器看到

```text
    expr - expr
```

它可以推迟立即应用规则，并继续读取输入，直到看到如下表达式为止

```text
        expr  -  expr  -  expr
```

然后可以将规则应用于最右边的三个符号，将其reduce为expr并保留

```text
        expr  -  expr
```

现在可以再次简化规则。 效果是采取右结合的解释。 因此，阅读

```text
        expr  -  expr
```

解析器可以做两种合法的事情，即移位或归约，并且无法在两者之间做出决定。 这称为转移/归约冲突。 解析器还可以选择两种合法的归约方法； 这称为归约/归约冲突。 请注意，永远不会有任何"Shift / shift"冲突。

```text
        stat    :       IF  '('  cond  ')'  stat
                |       IF  '('  cond  ')'  stat  ELSE  stat
                ;
```

当存在移位/归约或归约/归约冲突时，Yacc仍会生成解析器。它通过选择有效的步骤之一来做到这一点。描述给定情况下做出选择的规则称为消歧规则。

默认情况下，Yacc会调用两个消除歧义的规则：

1. 在移位/归约冲突中，默认设置为进行移位。
2. 在归约/归约冲突中，默认值是按照较早的语法规则(在输入序列中)进行归约。

规则1暗示，只要有选择，就归约延期，而有利于转移。规则2在这种情况下为用户提供了对解析器行为的粗略控制，但应尽可能避免归约/归约冲突。

由于输入或逻辑中的错误，或者因为语法规则虽然一致，但可能需要比Yacc能够构造的解析器更复杂的解析器，从而可能导致冲突。如果必须在解析器可以确定识别哪个规则之前执行操作，则在规则内使用操作也可能导致冲突。在这些情况下，应用歧义规则是不合适的，并且会导致错误的解析器。因此，Yacc始终报告规则1和规则2解决的移位/归约和归约/归约冲突的次数。

通常，只要有可能应用歧义消除规则来生成正确的解析器，就可以重写语法规则，以便读取相同的输入，但不会发生冲突。因此，大多数以前的解析器生成器都认为冲突是致命错误。我们的经验表明，这种重写有些不自然，并且会产生较慢的解析器。因此，即使存在冲突，Yacc也会生成解析器。

作为消除歧义的强大功能的一个示例，请考虑涉及"if-then-else"结构的编程语言的片段：

```text
        stat    :       IF  '('  cond  ')'  stat
                |       IF  '('  cond  ')'  stat  ELSE  stat
                ;
```

在这些规则中，IF和ELSE是标记，cond是描述条件(逻辑)表达式的非终结符，而stat是描述语句的非终结符。 第一个规则将被称为简单-if规则，第二个将被称为if-else规则。

这两个规则构成了一个模棱两可的结构，因为形式的输入

```text
        IF  (  C1  )  IF  (  C2  )  S1  ELSE  S2
```

可以按照以下两种方式根据这些规则进行结构化：

```text
        IF  (  C1  )  {
                IF  (  C2  )  S1
                }
        ELSE  S2
```

或者

```text
        IF  (  C1  )  {
                IF  (  C2  )  S1
                ELSE  S2
                }
```

第二种解释是在大多数编程语言中具有这种构造的解释。 每个ELSE与之前的最后一个"un-ELSE'd"IF相关联。 在此示例中，考虑解析器已经看到的情况

```text
        IF  (  C1  )  IF  (  C2  )  S1
```

并正在关注ELSE。 它可以立即通过简单-如果规则归约得到

```text
        IF  (  C1  )  stat
```

然后读取剩余的输入

```text
        ELSE  S2
```

并且规约

```text
        IF  (  C1  )  stat  ELSE  S2
```

根据if-else规则。 这导致上述输入中的第一个分组。
另一方面，可以移动ELSE，读取S2，然后将其右手部分

```text
        IF  (  C1  )  IF  (  C2  )  S1  ELSE  S2
```

可以通过if-else规则归约以获得

```text
        IF  (  C1  )  stat
```

可以通过“if else”规则来归约。 这导致通常需要上述第二组输入。
解析器可以再次执行两项有效的操作-发生移位/归约冲突。 消除歧义规则1的应用在这种情况下告诉解析器移动，从而导致期望的分组。

仅当存在特定的当前输入符号ELSE和已经看到的特定输入(例如，

```text
        IF  (  C1  )  IF  (  C2  )  S1
```

通常，可能存在许多冲突，并且每个冲突都将与一个输入符号和一组先前读取的输入相关联。 先前读取的输入以解析器的状态为特征。
通过检查详细(-v)选项输出文件，可以最好地理解Yacc的冲突消息。 例如，与上述冲突状态对应的输出可能是：

23：在ELSE上转移/归约冲突(转移45，归约18)

状态23

stat：IF(cond)stat_(18)stat：IF(cond)stat_ELSE stat

其他班次45。 归约18

第一行描述了冲突，并给出了状态和输入符号。 下面是普通的状态描述，给出了在该状态中处于活动状态的语法规则以及解析器动作。 回想一下，下划线表示已看到的语法规则部分。 因此，在该示例中，在状态23中，解析器看到的输入对应于

```text
        IF  (  cond  )  stat
```

并且显示的两个语法规则目前处于活动状态。 解析器可以做两种可能的事情。 如果输入符号为ELSE，则可以转换到状态45。状态45将作为其描述的一部分

```text
        stat  :  IF  (  cond  )  stat  ELSE_stat
```

因为ELSE将在此状态下转移。 回到状态23，如果在上述动作中未明确提及输入符号，则应执行用'.'描述的替代动作; 因此，在这种情况下，如果输入符号不是ELSE，则解析器将按照语法规则18进行缩减：

```text
        stat  :  IF  '('  cond  ')'  stat
```

再次注意，在'shift'命令后面的数字是指其他状态，而在"reduce"命令后面的数字是指语法规则数字。 在y.output文件中，规则编号在那些可以归约的规则之后打印。 在大多数状态下，该状态下最多只能执行reduce操作，这将是默认命令。 遇到意外的换档/归约冲突的用户可能希望查看详细的输出以确定默认操作是否合适。 在非常困难的情况下，用户可能需要了解更多关于解析器的行为和构造的知识，而这在这里是无法涵盖的。 在这种情况下，可以参考理论参考文献[2，3，4]之一。 当地专家的服务也可能适当。

## 6. 优先顺序

在一种常见的情况下，上面给出的解决冲突的规则还不够； 这是在算术表达式的解析中。 算术表达式的大多数常用构造自然可以通过运算符的优先级概念以及有关左或右结合性的信息来描述。 事实证明，具有适当歧义消除规则的歧义语法可用于创建解析器，该解析器比由歧义语法构造的解析器更快速，更容易编写。 基本概念是编写形式的语法规则

```text
        expr  :  expr  OP  expr
```

和

```text
        expr  :  UNARY  expr
```

适用于所有所需的二元和一元运算符。 这将创建一个非常含糊的语法，并带有许多解析冲突。 作为消除歧义的规则，用户可以指定所有运算符的优先级或绑定强度，以及二进制运算符的结合性。 此信息足以使Yacc根据这些规则解决解析冲突，并构造一个解析器，以实现所需的优先级和结合性。
优先级和结合性在声明部分中附加到标记。 这是通过一系列以Yacc关键字开头的行完成的：%left，%right或%nonassoc，后跟标记列表。 所有令牌都在同一行上

假定具有相同的优先级和结合性； 按优先级或绑定强度的增加顺序列出这些行。 从而，

```text
        %left  '+'  '-'
        %left  '*'  '/'
```

描述了四个算术运算符的优先级和结合性。 加号和减号保持结合，并且比星号和斜线(也保持结合)的优先级低。 关键字％right用于描述权限结合运算符，关键字％nonassoc用于描述运算符，例如运算符.LT。 在Fortran中，可能不会与自己结合； 从而，

```text
        A  .LT.  B  .LT.  C
```

在Fortran中是非法的，并且在Yacc中将用关键字％nonassoc描述此类运算符。 作为这些声明的行为的示例，描述

```text
        %right  '='
        %left  '+'  '-'
        %left  '*'  '/'

        %%

        expr    :       expr  '='  expr
                |       expr  '+'  expr
                |       expr  '-'  expr
                |       expr  '*'  expr
                |       expr  '/'  expr
                |       NAME
                ;
```

可能用于构造输入

```text
        a  =  b  =  c*d  -  e  -  f*g
```

像下面一样

```text
        a = ( b = ( ((c*d)-e) - (f*g) ) )
```

使用此机制时，通常必须给一元运算符一个优先级。 有时，一元运算符和二进制运算符具有相同的符号表示形式，但是优先级不同。 一个例子是一元和二进制'-'； 一元负号可能具有与乘法相同的强度，甚至更高，而二元负号具有比乘法低的强度。 关键字％prec更改与特定语法规则关联的优先级。 ％prec出现在语法规则的正文之后，操作或结束分号之前，并紧随其后的是标记名称或文字。 它使语法规则的优先级变为以下标记的优先级
名称或文字。 例如，要使一元减号具有与乘法相同的优先级，规则可能类似于：

```text
        %left  '+'  '-'
        %left  '*'  '/'

        %%

        expr    :       expr  '+'  expr
                |       expr  '-'  expr
                |       expr  '*'  expr
                |       expr  '/'  expr
                |       '-'  expr      %prec  '*'
                |       NAME
                ;
```

由％left，％right和％nonassoc声明的令牌也不必也可以由％token声明。

Yacc使用优先级和结合性来解决解析冲突。他们引起了歧义的规则。正式而言，规则的工作方式如下：

1. 记录具有它们的标记和文字的优先级和结合性。
2. 优先级和结合性与每个语法规则相关；它是规则主体中最后一个标记或文字的优先级和结合性。如果使用％prec构造，它将覆盖此默认值。某些语法规则可能没有与之相关的优先级和结合性。
3. 当存在归约/归约冲突或移位/归约冲突并且输入符号或语法规则没有优先级和结合性时，则使用本节开头给出的两个歧义规则，并且报告了冲突。
4. 如果存在移位/归约冲突，并且语法规则和输入字符都具有优先级和结合性，则可以通过优先级较高的操作(移位或归约)解决冲突。如果优先级相同，则使用结合性。左结合意味着归约，右结合意味着转移，而非结合意味着错误。

通过优先级解决的冲突不计入Yacc报告的转移/归约和归约/归约冲突的数量中。这意味着优先顺序规范中的错误可能掩盖了输入语法中的错误。最好保留优先级，并在优先级中使用优先级。

本质上是"烹饪书"时尚，直到获得一些经验。 y.output文件在确定解析器是否实际上在按预期进行时非常有用。

## 7. 错误处理

错误处理是一个极其困难的领域，许多问题都是语义问题。例如，当发现错误时，可能有必要回收解析树存储，删除或更改符号表条目，并且通常设置开关以避免产生任何进一步的输出。

发现错误时停止所有处理几乎是不可接受的。继续扫描输入以查找其他语法错误更为有用。这导致出现错误后解析器"重新启动"的问题。通用的算法类别包括从输入字符串中丢弃多个令牌，并尝试调整解析器，以便输入可以继续。

为了允许用户对该过程进行某种控制，Yacc提供了一个简单但合理的通用功能。令牌名称"error"保留用于错误处理。此名称可用于语法规则中。实际上，它建议可能发生错误的地方，并且可能会发生恢复。解析器弹出堆栈，直到进入令牌"错误"合法的状态。然后，其行为就好像令牌"错误"是当前的lookahead token一样，并执行遇到的操作。然后将lookahead token重置为导致错误的令牌。如果未指定任何特殊错误规则，则在检测到错误时暂停处理。

为了防止错误消息的级联，分析器在检测到错误后将保持错误状态，直到成功读取并转移了三个令牌为止。如果解析器已经处于错误状态时检测到错误，则不会给出任何消息，并且输入令牌将被悄悄删除。

例如，形式规则

```text
        stat    :       error
```

实际上，这意味着在语法错误时解析器将尝试跳过出现错误的语句。 更准确地说，解析器将向前扫描，寻找可能合法地跟随语句的三个令牌，并从第一个开始处理； 如果语句的开头没有足够的区分性，则可能在语句的中间错误地开始，并最终报告第二个错误，而实际上没有错误。
可以对这些特殊错误规则使用操作。 这些操作可能会尝试重新初始化表，回收符号表空间等。

诸如此类的错误规则非常笼统，但难以控制。 诸如以下的规则稍微容易一些

```text
        stat    :       error  ';'
```

在这里，当出现错误时，解析器会尝试跳过该语句，但是会通过跳至下一个';'来做到这一点。 错误之后且下一个';'之前的所有标记 无法移动，并被丢弃。 当 ';' 可以看到的时候，该规则将被简化，并且将执行与之相关的任何"清理"操作。
错误规则的另一种形式出现在交互式应用程序中，在这种情况下，可能需要允许在发生错误后重新输入一条线路。 可能的错误规则可能是

```text
        input   :       error  '\n'  {  printf( "Reenter last line: " );  }  input
                                {       $$  =  $4;  }
```

这种方法存在一个潜在的困难。 解析器必须在承认错误后正确重新同步之前，必须正确处理三个输入令牌。 如果重新输入的行的前两个令牌中包含错误，则解析器将删除有问题的令牌，并且不显示任何消息； 这显然是不可接受的。 因此，有一种机制可用于强制解析器认为错误已完全恢复。 该声明

```text
        yyerrok ;
```

在一个动作中，将解析器重置为其正常模式。 最后一个例子写得更好

```text
        input   :       error  '\n'
                                {       yyerrok;
                                        printf( "Reenter last line: " );   }
                        input
                                {       $$  =  $4;  }
                ;
```

如上所述，紧接在"错误"符号之后的令牌是发现错误的输入令牌。 有时，这是不合适的； 例如，错误恢复操作可能会自己承担寻找恢复输入的正确位置的工作。 在这种情况下，必须清除先前的lookahead token。 该声明

```text
        yyclearin ;
```

在一个动作中会产生这种效果。 例如，假设错误后的操作是调用用户提供的一些复杂的重新同步例程，该例程试图将输入推进到下一个有效语句的开头。 调用此例程后，yylex返回的下一个令牌将
大概是法律声明中的第一个标记； 必须丢弃旧的非法令牌，并重置错误状态。 这可以通过类似的规则来完成

```text
        stat    :       error
                                {       resynch();
                                        yyerrok ;
                                        yyclearin ;   }
                ;
```

这些机制虽然很粗糙，但是确实允许从许多错误中简单有效地恢复解析器。 此外，用户可以获得控制以处理程序其他部分所需的错误操作。

## 8. Yacc 环境

当用户向Yacc输入规范时，输出是C程序的文件，在大多数系统上称为y.tab.c(由于本地文件系统约定，名称因安装而异)。 Yacc产生的函数称为yyparse；它是一个整数函数。当它被调用时，它依次反复调用yylex，它是用户提供的词法分析器(请参见第3节)以获取输入令牌。最终，或者检测到错误，在这种情况下(如果不可能进行错误恢复)，yyparse返回值1，或者词法分析器返回结束标记令牌，并且解析器接受。在这种情况下，yyparse返回值0。

用户必须为此解析器提供一定数量的环境，以便获得工作程序。例如，与每个C程序一样，必须定义一个名为main的程序，该程序最终将调用yyparse。另外，当检测到语法错误时，称为yyerror的例程会打印一条消息。

这两个例程必须由用户以一种或另一种形式提供。为了简化使用Yacc的最初工作，已提供了一个库，其中包含main和yyerror的默认版本。该库的名称取决于系统。在许多系统上，该库是通过-ly参数访问加载程序的。为了说明这些默认程序的琐碎之处，下面给出了源代码：

```c
        main(){
                return( yyparse() );
                }
```

和

```c
        # include <stdio.h>

        yyerror(s) char *s; {
                fprintf( stderr, "%s\n", s );
                }
```

yyerror的参数是一个包含错误消息的字符串，通常是字符串"syntax error"。 普通应用程序将希望做得更好。 通常，程序应跟踪输入的行号，并在检测到语法错误时将其与消息一起打印。 外部整数变量yychar包含检测到错误时的lookahead token号。 这可能对提供更好的诊断很有帮助。 由于主程序可能由用户提供(以读取参数等)，因此Yacc库仅在小型项目或大型项目的早期阶段才有用。
外部整数变量yydebug通常设置为0。如果将其设置为非零值，则解析器将输出对其动作的详细描述，包括有关已读取哪些输入符号以及解析器动作是什么的讨论。 根据操作环境，可能可以通过使用调试系统来设置此变量。

## 9. 准备规范的提示

本节包含有关准备高效，易更改和清晰规范的其他提示。各个小节或多或少是独立的。

输入方式

很难为规则提供实质性的操作，并且仍然具有可读的规范文件。以下样式示意归功于Brian Kernighan。

1. 所有大写字母用于令牌名称，所有小写字母用于非终结符名称。该规则属于"知道出问题时应该归咎于谁"的标题。
2. 将语法规则和动作放在单独的行上。这允许更改其中一个而无需自动更改另一个。
3. 将所有规则以相同的左手放在一起。仅将左侧放置一次，然后让所有以下规则以竖线开头。
4. 仅在最后一条规则之后用给定的左侧放置分号，然后将分号放在单独的行上。这样可以轻松添加新规则。
5. 通过两个制表符缩进规则主体，并通过三个制表符缩进动作主体。

附录A中的示例是按照这种样式编写的，就像本文中的示例(在空间允许的情况下)一样。用户必须对这些样式问题下定决心。然而，中心问题是使规则在行动代码的混乱中可见。

左递归

Yacc解析器使用的算法鼓励所谓的"左递归"语法规则：形式规则

```text
        name    :       name  rest_of_rule  ;
```

这些规则在编写序列和列表的规范时经常出现：

```text
        list    :       item
                |       list  ','  item
                ;
```

和

```text
        seq     :       item
                |       seq  item
                ;
```

在每种情况下，仅针对第一项归约第一条规则，针对第二项和所有后续项归约第二条规则。
具有正确的递归规则，例如

```text
        seq     :       item
                |       item  seq
                ;
```

解析器会更大一些，并且从右到左可以看到并归约项目。 更严重的是，如果读取了很长的序列，解析器中的内部堆栈将有溢出的危险。 因此，用户应在合理的情况下使用左递归。
值得考虑的是具有零个元素的序列是否具有任何含义，如果是，则考虑使用空规则编写序列规范：

```text
        seq     :       /* empty */
                |       seq  item
                ;
```

再一次，在读取第一个项目之前，第一个规则将总是精确地归约一次，然后对于每个读取的项目，将第二个规则归约一次。 允许空序列通常会提高通用性。 但是，如果要求Yacc决定尚未看到的空序列，则可能会产生冲突！
词汇绑定

一些词汇决定取决于上下文。 例如，

词法分析器可能希望正常删除空格，但不要在带引号的字符串中删除空格。 或者名称可能会在声明中输入符号表，但不能在表达式中输入。

处理这种情况的一种方法是创建一个全局标志，该全局标志由词法分析器检查并由操作设置。 例如，假设一个程序包含0个或多个声明，后跟0个或多个语句。 考虑：

```text
        %{
                int dflag;
        %}
          ...  other declarations ...

        %%

        prog    :       decls  stats
                ;

        decls   :       /* empty */
                                {       dflag = 1;  }
                |       decls  declaration
                ;

        stats   :       /* empty */
                                {       dflag = 0;  }
                |       stats  statement
                ;

            ...  other rules ...
```

现在，标志dflag在读取语句时为0，在读取声明时为1，但第一个语句中的第一个标记除外。解析器必须先看到此令牌，才能知道声明部分已结束且语句已开始。在许多情况下，此单个令牌异常不会影响词​​法扫描。
这种"后门"方法可以阐述到有害程度。然而，它代表了一种做某事的方法，而这些事情即使不是不可能的，也很难做到。

保留字

某些编程语言允许用户使用诸​​如"if"之类的通常保留的词作为标签或变量名，前提是这种使用与编程语言中这些名称的合法使用不冲突。在Yacc的框架中，这很难做到；很难将信息传递给词法分析器，告诉它"if的这个实例是关键字，而那个实例是变量"。用户可以使用上一小节中描述的机制对其进行刺刺，但这很困难。

建议使用多种方法来简化此过程。在此之前，最好保留关键字。也就是说，禁止将其用作变量名。无论如何，有很强的风格上的理由喜欢这种方式。

## 10. 高级话题

本节讨论了Yacc的许多高级功能。

模拟错误并接受操作

可以使用宏YYACCEPT和YYERROR在一个动作中模拟错误和接受的解析动作。 YYACCEPT使yyparse返回值0；否则，返回0。 YYERROR使解析器的行为类似于当前输入符号是语法错误； 调用yyerror，并进行错误恢复。 这些机制可用于模拟具有多个结束标记的解析器或上下文相关的语法检查。

访问封闭规则中的值。

一个动作可以引用当前规则左侧的动作返回的值。 该机制与普通操作完全相同，一个美元符号后跟一个数字，但是在这种情况下，该数字可能为0或负数。 考虑

```text
        sent    :       adj  noun  verb  adj  noun
                                {  look at the sentence . . .  }
                ;

        adj     :       THE             {       $$ = THE;  }
                |       YOUNG   {       $$ = YOUNG;  }
                . . .
                ;

        noun    :       DOG
                                {       $$ = DOG;  }
                |       CRONE
                                {       if( $0 == YOUNG ){
                                                printf( "what?\n" );
                                                }
                                        $$ = CRONE;
                                        }
                ;
                . . .
```

在单词CRONE之后的动作中，检查前面的标记移位后是否为YOUNG。显然，只有在大量了解输入中符号名词之前的内容时，才有可能。也有明显的非结构化味道。不过，有时这种机制会省去很多麻烦，尤其是当一些组合从其他常规结构中排除时。
支持任意值类型

默认情况下，actions和词法分析器返回的值是整数。 Yacc还可以支持其他类型的值，包括结构。此外，Yacc会跟踪类型，并插入适当的并集成员名称，以便对生成的解析器进行严格的类型检查。 Yacc值堆栈(请参见第4节)声明为所需的各种类型的值的并集。用户声明联合，并将联合成员名称与每个令牌和具有值的非终止符号相关联。当通过$$或$ n构造引用值时，Yacc将自动插入适当的并集名称，这样就不会发生不需要的转换。此外，类型检查命令(如Lint [5])将更加安静。

有三种用于提供此类型的机制。首先，有一种定义联合的方法；这必须由用户完成，因为其他程序(尤其是词法分析器)必须知道联合成员名称。其次，有一种将工会成员名称与令牌和非终端关联的方法。最后，有一种机制可以描述那些少数值的类型，而Yacc无法轻易确定这些类型。

要声明联合，用户在声明部分中包括：

```text
        %union  {
                body of union ...
                }
```

这声明Yacc值堆栈以及外部变量yylval和yyval具有与该联合相同的类型。 如果使用-d选项调用了Yacc，则将联合声明复制到y.tab.h文件中。 或者，可以在头文件中声明联合，并使用typedef定义变量YYSTYPE来表示该联合。 因此，头文件可能还说：

```text
        typedef union {
                body of union ...
                } YYSTYPE;
```

必须使用％{和％}将头文件包含在声明部分中。
定义YYSTYPE后，联合成员名称必须与各种终端和非终端名称相关联。 那个工程

```text
        < name >
```

用于表示工会成员名称。 如果它遵循关键字％token，％left，％right和％nonassoc之一，则该联合
成员名称与列出的令牌关联。 因此，说

```text
        %left  <optype>  '+'  '-'
```

将导致对这两个令牌返回的值的任何引用都用联合成员名称optype标记。 另一个关键字％type类似地用于将工会成员名称与非终端相关联。 因此，有人可能会说

```text
        %type  <nodetype>  expr  stat
```

在某些情况下，这些机制还不够充分。 如果规则中有操作，则此操作返回的值没有先验类型。 同样，对左上下文值(例如$ 0-参见上一小节)的引用使Yacc无法轻松知道类型。 在这种情况下，可以通过在第一个$之后紧跟在<和>之间插入一个联合成员名称来对引用强加类型。 这种用法的一个例子是

```text
        rule    :       aaa  {  $<intval>$  =  3;  } bbb
                                {       fun( $<intval>2, $<other>0 );  }
                ;
```

这种语法几乎不值得推荐，但是这种情况很少出现。
附录C中给出了样本规范。只有在使用本节中的功能之后，这些功能才会被触发：特别是，使用％type将打开这些机制。 使用它们时，存在相当严格的检查级别。 例如，诊断为使用$ n或$$引用没有定义类型的东西。 如果未触发这些功能，则使用Yacc值堆栈来保存int，这在历史上是正确的。

## 11. 致谢

Yacc在很大程度上要归功于最激动人心的用户群体，他们无休止地寻找"一个新功能"，这使我超出了我的兴趣，而且常常超出了我的能力。 他们不愿学习以我的方式做事的烦恼通常导致我以自己的方式做事。 大多数时候，他们是对的。 B. W. Kernighan，P。J. Plauger，S。I. Feldman，C。Imagna，M。E. Lesk和A. Snyder将在当前版本的Yacc中认识到他们的一些想法。 C. B. Haley为错误恢复算法做出了贡献。 D. M. Ritchie，B。W. Kernighan和M. O. Harris帮助将该文档翻译成英文。 Al Aho还因将山带到穆罕默德(Mohammed)而获得其他荣誉。

References

1. B. W. Kernighan and D. M. Ritchie, The C Programming Language, Prentice-Hall, Englewood Cliffs, New Jersey, 1978.

2. A. V. Aho and S. C. Johnson, "LR Parsing," Comp. Surveys, vol. 6, no. 2, pp. 99-124, June 1974.

3. A. V. Aho, S. C. Johnson, and J. D. Ullman, "Deterministic Parsing of Ambiguous Grammars," Comm. Assoc. Comp. Mach., vol. 18, no. 8, pp. 441-452, August 1975.

4. A. V. Aho and J. D. Ullman, Principles of Compiler Design, Addison-Wesley, Reading, Mass., 1977.

5. S. C. Johnson, "Lint, a C Program Checker," Comp. Sci. Tech. Rep. No. 65, 1978 .]. updated version TM 78-1273-3

6. S. C. Johnson, "A Portable Compiler: Theory and Practice," Proc. 5th ACM Symp. on Principles of Programming Languages, pp. 97-104, January 1978.

7. B. W. Kernighan and L. L. Cherry, "A System for Typesetting Mathematics," Comm. Assoc. Comp. Mach., vol. 18, pp. 151-157, Bell Laboratories, Murray Hill, New Jersey, March 1975 .].

8. M. E. Lesk, "Lex - A Lexical Analyzer Generator," Comp. Sci. Tech. Rep. No. 39, Bell Laboratories, Murray Hill, New Jersey, October 1975 .].

附录A：一个简单的例子

本示例给出了小型台式计算器的完整Yacc规范。 桌面计算器有26个寄存器，分别标记为“ a”至“ z”，并接受由运算符+，-，*，/，％(mod运算符)，＆(按位与)，|组成的算术表达式。 (按位或)，以及赋值。 如果顶层的表达式是一个赋值，则不打印该值； 否则。 与C中一样，假定以0(零)开头的整数是八进制的。 否则，假定为十进制。

作为Yacc规范的示例，桌面计算器在显示如何使用优先级和歧义性以及演示简单的错误恢复方面做了合理的工作。 主要的过分简化是，词法分析阶段比大多数应用程序要简单得多，并且输出是逐行立即产生的。 注意语法规则读取十进制和八进制整数的方式。 词法分析器可能会更好地完成这项工作。

```text
%{
#  include  <stdio.h>
#  include  <ctype.h>

int  regs[26];
int  base;

%}

%start  list

%token  DIGIT  LETTER

%left  '|'
%left  '&'
%left  '+'  '-'
%left  '*'  '/'  '%'
%left  UMINUS      /*  supplies  precedence  for  unary  minus  */

%%      /*  beginning  of  rules  section  */

list :    /*  empty  */
     |    list  stat  '\n'
     |    list  error  '\n'
               {    yyerrok;  }
     ;

stat :    expr
               {    printf( "%d\n", $1 );  }
     |    LETTER  '='  expr
               {    regs[$1]  =  $3;  }
     ;


expr :    '('  expr  ')'
               {    $$  =  $2;  }
     |    expr  '+'  expr
               {    $$  =  $1  +  $3;  }
     |    expr  '-'  expr
               {    $$  =  $1  -  $3;  }
     |    expr  '*'  expr
               {    $$  =  $1  *  $3;  }
     |    expr  '/'  expr
               {    $$  =  $1  /  $3;  }
     |    expr  '%'  expr
               {    $$  =  $1  %  $3;  }
     |    expr  '&'  expr
               {    $$  =  $1  &  $3;  }
     |    expr  '|'  expr
               {    $$  =  $1  |  $3;  }
     |    '-'  expr        %prec  UMINUS
               {    $$  =  -  $2;  }
     |    LETTER
               {    $$  =  regs[$1];  }
     |    number
     ;

number    :    DIGIT
               {    $$ = $1;    base  =  ($1==0)  ?  8  :  10;  }
     |    number  DIGIT
               {    $$  =  base * $1  +  $2;  }
     ;

%%      /*  start  of  programs  */

yylex() {      /*  lexical  analysis  routine  */
              /*  returns  LETTER  for  a  lower  case  letter,  yylval = 0  through  25  */
              /*  return  DIGIT  for  a  digit,  yylval = 0  through  9  */
              /*  all  other  characters  are  returned  immediately  */

     int  c;

     while(  (c=getchar())  ==  ' '  )  {/*  skip  blanks  */  }

     /*  c  is  now  nonblank  */

     if(  islower(  c  )  )  {
          yylval  =  c  -  'a';
          return  (  LETTER  );
          }
     if(  isdigit(  c  )  )  {
          yylval  =  c  -  '0';
          return(  DIGIT  );
          }
     return(  c  );
     }
```

附录B：Yacc输入语法
本附录以Yacc规范的形式描述了Yacc输入语法。 不考虑上下文相关性等。 具有讽刺意味的是，Yacc输入规范语言最自然地被指定为LR(2)语法。 当在操作中立即在规则中看到标识符时，便会出现粘性部分。 如果此标识符后跟冒号，则它是下一条规则的开始； 否则，它是当前规则的延续，只是在其中嵌入了一个动作。 按照实现，词法分析器将在看到标识符后向前看，并确定下一个标记(跳过空格，换行符，注释等)是否为冒号。 如果是这样，它将返回令牌C_IDENTIFIER。 否则，它返回IDENTIFIER。 文字(带引号的字符串)也作为IDENTIFIERS返回，但绝不作为C_IDENTIFIERs的一部分返回。

```text
            /*  grammar  for  the  input  to  Yacc  */

      /*  basic  entities  */
%token      IDENTIFIER  /*   includes  identifiers   and  literals  */
%token      C_IDENTIFIER      /*    identifier  (but  not  literal)  followed  by  colon    */
%token      NUMBER            /*    [0-9]+    */

      /*  reserved  words:    %type  =>  TYPE,  %left  =>  LEFT,  etc.  */

%token      LEFT  RIGHT  NONASSOC  TOKEN  PREC  TYPE  START  UNION

%token      MARK  /*  the  %%  mark  */
%token      LCURL /*  the  %{  mark  */
%token      RCURL /*  the  %}  mark  */

      /*  ascii  character  literals  stand  for  themselves  */

%start      spec

%%

spec  :     defs  MARK  rules  tail
      ;

tail  :     MARK  {    In  this  action,  eat  up  the  rest  of  the  file    }
      |     /*  empty:  the  second  MARK  is  optional  */
      ;

defs  :     /*  empty  */
      |     defs  def
      ;

def   :     START  IDENTIFIER
      |     UNION  {  Copy union  definition  to  output  }
      |     LCURL  {  Copy  C  code  to  output  file   }  RCURL
      |     ndefs  rword  tag  nlist
      ;

rword :     TOKEN
      |     LEFT
      |     RIGHT
      |     NONASSOC
      |     TYPE
      ;

tag   :     /*  empty:  union  tag  is  optional  */
      |     '<'  IDENTIFIER  '>'
      ;

nlist :     nmno
      |     nlist  nmno
      |     nlist  ','  nmno
      ;

nmno  :     IDENTIFIER        /*  NOTE:  literal  illegal  with  %type  */
      |     IDENTIFIER  NUMBER      /*  NOTE:  illegal  with  %type  */
      ;

      /*  rules  section  */

rules :     C_IDENTIFIER  rbody  prec
      |     rules  rule
      ;

rule  :     C_IDENTIFIER  rbody  prec
      |     '|'  rbody  prec
      ;

rbody :     /*  empty  */
      |     rbody  IDENTIFIER
      |     rbody  act
      ;

act   :     '{'  {  Copy  action,  translate  $$,  etc.  }  '}'
      ;

prec  :     /*  empty  */
      |     PREC  IDENTIFIER
      |     PREC  IDENTIFIER  act
      |     prec  ';'
      ;
```

附录B：Yacc输入语法
本附录以Yacc规范的形式描述了Yacc输入语法。 不考虑上下文相关性等。 具有讽刺意味的是，Yacc输入规范语言最自然地被指定为LR(2)语法。 当在操作中立即在规则中看到标识符时，便会出现粘性部分。 如果此标识符后跟冒号，则它是下一条规则的开始； 否则，它是当前规则的延续，只是在其中嵌入了一个动作。 按照实现，词法分析器将在看到标识符后向前看，并确定下一个标记(跳过空格，换行符，注释等)是否为冒号。 如果是这样，它将返回令牌C_IDENTIFIER。 否则，它返回IDENTIFIER。 文字(带引号的字符串)也作为IDENTIFIERS返回，但绝不作为C_IDENTIFIERs的一部分返回。...

```text
                ( x , y )
```

其中x小于或等于y。也可以使用26个区间值变量"A"至"Z"。用法与附录A中的用法相似。赋值不返回任何值，也不打印任何内容，而表达式则打印(浮动或间隔)值。
本示例探讨了Yacc和C的许多有趣特征。间隔由一个结构表示，该结构由左右端点值组成，并存储为double值。通过使用typedef，此结构的类型名称为INTERVAL。 Yacc值堆栈还可以包含浮点标量和整数(用于索引包含可变值的数组)。请注意，整个策略在很大程度上取决于能否在C中分配结构和联合。实际上，许多动作也调用返回结构的函数。

还值得注意的是，使用YYERROR处理错误情况：除以包含0的间隔，并按错误的顺序显示间隔。实际上，Yacc的错误恢复机制用于丢弃其余的违规行。

除了在值堆栈上混合类型外，此语法还演示了一种有趣的语法用法，用于跟踪中间表达式的类型(例如标量或间隔)。请注意，如果上下文需要间隔值，则标量可以自动提升为间隔。通过Yacc运行语法时，这会导致大量冲突：18 Shift / Reduce和26 Reduce / Reduce。通过查看两条输入线可以看到问题：

```text
                2.5 + ( 3.5 - 4. )
```

```text
                2.5 + ( 3.5 , 4. )
```

请注意，在第二个示例中将在间隔值表达式中使用2.5，但是直到读取','才知道这一事实;到此时，2.5已完成，解析器无法返回并改变主意。更一般而言，可能是
有必要提前查看任意数量的令牌，以决定是否将标量转换为区间。通过为每个二进制间隔值运算符设置两个规则来避免此问题：一个规则在左操作数为标量时，一个规则在左操作数为间隔时。在第二种情况下，右操作数必须是一个间隔，因此转换将自动应用。尽管有这种回避，仍然有很多情况下是否可以应用转换，从而导致上述冲突。通过在规范文件中首先列出产生标量的规则来解决它们。以此方式，将在保持标量值表达式标量值的方向上解决冲突，直到迫使它们成为间隔为止。

这种处理多个类型的方法很有启发性，但不是很通用。如果有很多类型的表达式类型，而不是只有两种，那么所需的规则数量将急剧增加，并且冲突会更加急剧。因此，尽管此示例具有指导意义，但在更常规的编程语言环境中，更好的做法是将类型信息保留为值的一部分，而不是语法的一部分。

最后，谈谈词法分析。唯一不寻常的功能是对浮点常量的处理。 C库例程atof用于执行从字符串到双精度值的实际转换。如果词法分析器检测到错误，它将通过返回语法中非法的标记，在解析器中引发语法错误并由此恢复错误来作出响应。

```text
%{

#  include  <stdio.h>
#  include  <ctype.h>

typedef  struct  interval  {
        double  lo,  hi;
        }  INTERVAL;

INTERVAL  vmul(),  vdiv();

double  atof();

double  dreg[ 26 ];
INTERVAL  vreg[ 26 ];

%}

%start    lines

%union    {
        int  ival;
        double  dval;
        INTERVAL  vval;
        }

%token  <ival>  DREG  VREG      /*  indices  into  dreg,  vreg  arrays  */

%token  <dval>  CONST           /*  floating  point  constant  */

%type  <dval>  dexp             /*  expression  */

%type  <vval>  vexp             /*  interval  expression  */

        /*  precedence  information  about  the  operators  */

%left   '+'  '-'
%left   '*'  '/'
%left   UMINUS        /*  precedence  for  unary  minus  */

%%

lines   :       /*  empty  */
        |       lines  line
        ;

line    :       dexp  '\n'
                        {       printf(  "%15.8f\n",  $1  );  }
        |       vexp  '\n'
                        {       printf(  "(%15.8f  ,  %15.8f  )\n",  $1.lo,  $1.hi  );  }
        |       DREG  '='  dexp  '\n'
                        {       dreg[$1]  =  $3;  }
        |       VREG  '='  vexp  '\n'
                        {       vreg[$1]  =  $3;  }
        |       error  '\n'
                        {       yyerrok;  }
        ;

dexp    :       CONST
        |       DREG
                        {       $$  =  dreg[$1];  }
        |       dexp  '+'  dexp
                        {       $$  =  $1  +  $3;  }
        |       dexp  '-'  dexp
                        {       $$  =  $1  -  $3;  }
        |       dexp  '*'  dexp
                        {       $$  =  $1  *  $3;  }
        |       dexp  '/'  dexp
                        {       $$  =  $1  /  $3;  }
        |       '-'  dexp       %prec  UMINUS
                        {       $$  =  - $2;  }
        |       '('  dexp  ')'
                        {       $$  =  $2;  }
        ;

vexp    :       dexp
                        {       $$.hi  =  $$.lo  =  $1;  }
        |       '('  dexp  ','  dexp  ')'
                        {
                        $$.lo  =  $2;
                        $$.hi  =  $4;
                        if(  $$.lo  >  $$.hi  ){
                                printf(  "interval  out  of  order\n"  );
                                YYERROR;
                                }
                        }
        |       VREG
                        {       $$  =  vreg[$1];    }
        |       vexp  '+'  vexp
                        {       $$.hi  =  $1.hi  +  $3.hi;
                                $$.lo  =  $1.lo  +  $3.lo;    }
        |       dexp  '+'  vexp
                        {       $$.hi  =  $1  +  $3.hi;
                                $$.lo  =  $1  +  $3.lo;    }
        |       vexp  '-'  vexp
                        {       $$.hi  =  $1.hi  -  $3.lo;
                                $$.lo  =  $1.lo  -  $3.hi;    }
        |       dexp  '-'  vexp
                        {       $$.hi  =  $1  -  $3.lo;
                                $$.lo  =  $1  -  $3.hi;    }
        |       vexp  '*'  vexp
                        {       $$  =  vmul(  $1.lo,  $1.hi,  $3  );  }
        |       dexp  '*'  vexp
                        {       $$  =  vmul(  $1,  $1,  $3  );  }
        |       vexp  '/'  vexp
                        {       if(  dcheck(  $3  )  )  YYERROR;
                                $$  =  vdiv(  $1.lo,  $1.hi,  $3  );  }
        |       dexp  '/'  vexp
                        {       if(  dcheck(  $3  )  )  YYERROR;
                                $$  =  vdiv(  $1,  $1,  $3  );  }
        |       '-'  vexp       %prec  UMINUS
                        {       $$.hi  =  -$2.lo;    $$.lo  =  -$2.hi;    }
        |       '('  vexp  ')'
                        {       $$  =  $2;  }
        ;

%%

#  define  BSZ  50        /*  buffer  size  for  floating  point  numbers  */

        /*  lexical  analysis  */

yylex(){
        register  c;

        while(  (c=getchar())  ==  ' '  ){  /*  skip  over  blanks  */  }

        if(  isupper(  c  )  ){
                yylval.ival  =  c  -  'A';
                return(  VREG  );
                }
        if(  islower(  c  )  ){
                yylval.ival  =  c  -  'a';
                return(  DREG  );
                }

        if(  isdigit(  c  )  ||  c=='.'  ){
                /*  gobble  up  digits,  points,  exponents  */

                char  buf[BSZ+1],  *cp  =  buf;
                int  dot  =  0,  exp  =  0;

                for(  ;  (cp-buf)<BSZ  ;  ++cp,c=getchar()  ){

                        *cp  =  c;
                        if(  isdigit(  c  )  )  continue;
                        if(  c  ==  '.'  ){
                                if(  dot++  ||  exp  )  return(  '.'  );    /*  will  cause  syntax  error  */
                                continue;
                                }

                        if(  c  ==  'e'  ){
                                if(  exp++  )  return(  'e'  );    /*  will  cause  syntax  error  */
                                continue;
                                }

                        /*  end  of  number  */
                        break;
                        }
                *cp  =  '\0';

                if(  (cp-buf)  >=  BSZ  )  printf(  "constant  too  long:  truncated\n"  );
                else  ungetc(  c,  stdin  );    /*  push  back  last  char  read  */
                yylval.dval  =  atof(  buf  );
                return(  CONST  );
                }
        return(  c  );
        }

INTERVAL  hilo(  a,  b,  c,  d  )  double  a,  b,  c,  d;  {
        /*  returns  the  smallest  interval  containing  a,  b,  c,  and  d  */
        /*  used  by  *,  /  routines  */
        INTERVAL  v;

        if(  a>b  )  {  v.hi  =  a;    v.lo  =  b;  }
        else  {  v.hi  =  b;    v.lo  =  a;  }

        if(  c>d  )  {
                if(  c>v.hi  )  v.hi  =  c;
                if(  d<v.lo  )  v.lo  =  d;
                }
        else  {
                if(  d>v.hi  )  v.hi  =  d;
                if(  c<v.lo  )  v.lo  =  c;
                }
        return(  v  );
        }

INTERVAL  vmul(  a,  b,  v  )  double  a,  b;    INTERVAL  v;  {
        return(  hilo(  a*v.hi,  a*v.lo,  b*v.hi,  b*v.lo  )  );
        }

dcheck(  v  )  INTERVAL  v;  {
        if(  v.hi  >=  0.  &&  v.lo  <=  0.  ){
                printf(  "divisor  interval  contains  0.\n"  );
                return(  1  );
                }
        return(  0  );
        }

INTERVAL  vdiv(  a,  b,  v  )  double  a,  b;    INTERVAL  v;  {
        return(  hilo(  a/v.hi,  a/v.lo,  b/v.hi,  b/v.lo  )  );
        }
```

其中x小于或等于y。也可以使用26个区间值变量"A"至"Z"。用法与附录A中的用法相似。赋值不返回任何值，也不打印任何内容，而表达式则打印(浮动或间隔)值。
本示例探讨了Yacc和C的许多有趣特征。间隔由一个结构表示，该结构由左右端点值组成，并存储为double值。通过使用typedef，此结构的类型名称为INTERVAL。 Yacc值堆栈还可以包含浮点标量和整数(用于索引包含可变值的数组)。请注意，整个策略在很大程度上取决于能否在C中分配结构和联合。实际上，许多动作也调用返回结构的函数。

还值得注意的是，使用YYERROR处理错误情况：除以包含0的间隔，并按错误的顺序显示间隔。实际上，Yacc的错误恢复机制用于丢弃其余的违规行。

除了在值堆栈上混合类型外，此语法还演示了一种有趣的语法用法，用于跟踪中间表达式的类型(例如标量或间隔)。请注意，如果上下文需要间隔值，则标量可以自动提升为间隔。通过Yacc运行语法时，这会导致大量冲突：18 Shift / Reduce和26 Reduce / Reduce。通过查看两条输入线可以看到问题：...

```text
             %< is the same as %left
             %> is the same as %right
             %binary and %2 are the same as %nonassoc
             %0 and %term are the same as %token
             %= is the same as %prec
```

5.动作也可以采用以下形式

```text
             ={ . . . }
```

如果操作是单个C语句，则可以删除花括号。
6.规则部分和声明部分的开头曾经允许％{和％}之间的C代码。
