# Lex - 一个语法分析器生成器

Document source: [Lex Manual](http://dinosaur.compilertools.net/lex/index.html)

## 概要

Lex帮助编写程序，程序的控制流由输入流中的正则表达式实例控制。它非常适用于编辑器脚本类型的转换以及分段输入，以准备解析例程。
Lex源是一个有正则表达式和相应程序片段的表。该表被转换为程序，该程序读取输入流，将其复制到输出流，然后将输入划分为与给定表达式匹配的字符串。识别出每个这样的字符串后，就会执行相应的程序片段。表达式的识别是由Lex生成的确定性有限自动机执行的。由用户编写的程序片段按在输入流中与其相应的正则表达式的出现顺序执行。

用Lex编写的词法分析程序接受模棱两可的规范，并在每个输入点选择尽可能长的匹配项。如有必要，会对输入执行大量的向前看操作，但是输入流将被备份到当前分区的末尾，因此用户可以自由地进行操作。

Lex可以用C或Ratfor生成分析器，这种语言可以自动翻译为便携的Fortran语言。它在PDP-11 UNIX，霍尼韦尔GCOS和IBM OS系统上可用。但是，本手册仅讨论在UNIX系统上使用C语言生成分析器的情况，这是UNIX Version7下Lex唯一受支持的形式。Lex的设计旨在简化与Yacc的接口，为了那些可以访问此编译器-编译器系统的人/软件。

## 1.介绍

Lex是一个程序生成器，旨在对字符输入流进行词汇处理。它接受用于字符串匹配的高层次、面向问题的规范，并以通用语言生成可识别的正则表达式的程序。用户在给Lex的源规范中指定了正则表达式。 Lex编写的代码识别输入流中的这些表达式，并将输入流划分为与表达式匹配的字符串。在字符串之间的边界处，执行用户提供的程序段。 Lex源文件将正则表达式和程序片段相关联。当每个表达式出现在Lex编写的程序的输入中时，将执行相应的片段。

用户提供了完成任务所需的表达式匹配工作之外的其他代码，可能包括其他生成器编写的代码。识别表达式的程序是以用于用户程序片段的通用编程语言生成的。因此，提供了高级表达语言来编写要匹配的字符串表达式，同时用户的写入动作自由度不受损害。这避免了迫使希望使用字符串操作语言进行输入分析的用户以相同且通常不合适的字符串处理语言编写处理程序。

Lex不是一种完整的语言，而是代表一种新语言功能的生成器，可以将其添加到称为"宿主语言”的不同编程语言中。就像通用语言可以生成在不同计算机硬件上运行的代码一样，Lex可以用不同的宿主语言编写代码。宿主语言会用于Lex生成的输出代码，也用于用户添加的程序片段。还提供了适用于不同宿主语言的兼容运行时库。这使Lex可以适应不同的环境和不同的使用者。可以将每个应用程序定向到适合于任务，用户的背景以及本地实现的属性的硬件和宿主语言的组合。当前，唯一支持的宿主语言是C，尽管Fortran(以Ratfor [2]的形式在过去可用。Lex本身存在于UNIX，GCOS和OS / 370上；但是Lex生成的代码可能被使用在合适的编译器存在的任何地方。

Lex将使用者的表达式和动作(在本备忘录中称为Source)转换为宿主通用语言。 生成的程序名为yylex。 yylex程序将识别流中的表达式(在本备忘录中称为输入)，并在检测到每个表达式时对每个表达式执行指定的操作。 参见图1。

```text
                                  +-------+
                        Source -> |  Lex  |  -> yylex
                                  +-------+

                                  +-------+
                        Input ->  | yylex | -> Output
                                  +-------+

                             An overview of Lex
                                  Figure 1
```

举一个简单的例子，考虑一个程序从输入端删除行末的所有空白或制表符。

```text
                                 %%
                                 [ \t]+$   ;
```

所需要的仅此而已。 该程序包含一个%%分隔符(用于标记规则的开头)和一个规则。 该规则包含一个正则表达式，该正则表达式与行尾之前的一个或多个字符空白或制表符实例(根据C语言约定，为了可视性写作\t)匹配。 括号表示由空格和制表符组成的字符类； +表示"一个或多个..."; 和QED中一样，$表示"行尾"。 没有指定任何操作，因此Lex(yylex)生成的程序将忽略这些字符。 其他所有内容都会被复制。 要将任何剩余的空格或制表符字符串更改为单个空格，请添加另一条规则：

```text
                           %%
                           [ \t]+$   ;
                           [ \t]+    printf(" ");
```

为此源生成的有限自动机将立即扫描这两个规则，在空格或制表符字符串的结尾处观察是否有换行符，并执行所需的规则操作。第一条规则与行末尾的所有空格或制表符字符串匹配，第二条规则与其余所有空格或制表符的字符串匹配。

Lex可以单独用于简单转换，也可以用于词法级别的分析和统计。 Lex也可以与解析器生成器一起使用以执行词法分析阶段。 Lex和Yacc的接口特别容易[3]。 Lex程序仅识别正则表达式； Yacc编写的解析器接受大量的上下文无关文法，但需要较低级别的分析器来识别输入令牌。因此，通常将Lex和Yacc结合使用是合适的。当用作更高版本的解析器生成器的预处理器时，Lex被用来对输入流进行分区，解析器生成器将结构分配给结果片段。这种情况下的控制流程(例如，可能是编译器的前半部分)如图2所示。可以将其他生成器或手动编写的其他程序轻松添加到Lex编写的程序中。

```text
                        lexical        grammar
                         rules          rules
                           |              |
                           v              v
                      +---------+    +---------+
                      |   Lex   |    |  Yacc   |
                      +---------+    +---------+
                           |              |
                           v              v
                      +---------+    +---------+
             Input -> |  yylex  | -> | yyparse | -> Parsed input
                      +---------+    +---------+


                            Lex with Yacc
                               Figure 2
```

Yacc用户将认识到yylex是Yacc期望其词法分析器被命名的名称，因此Lex使用此名称可以简化接口。

Lex根据源中的正则表达式生成确定性有限自动机[4]。为了节省空间，将对自动机进行解释而不是进行编译。结果仍然是一个快速的分析器。特别是，Lex程序识别和划分输入流所花费的时间与输入的长度成正比。 Lex规则的数量或规则的复杂性对于速度的决定并不重要，除非包含前向上下文的规则需要大量的重新扫描。随着规则的数量和复杂性的增加，有限自动机的大小会增加，因此Lex生成的程序的大小也会增加。

在Lex编写的程序中，将用户的片段(表示找到每个正则表达式时要执行的动作)收集为开关的情况。自动机解释器指导着控制流。为用户提供了在包含动作的例程中插入声明或其他语句的机会，或在此动作例程之外添加子例程的机会。

Lex不限于可以基于一个向前看字符进行解释的源。例如，如果有两个规则，一个寻找ab，另一个寻找abcdefg，并且输入流是abcdefh，那么Lex将识别ab并将输入指针留在cd...之前。 这种备份比处理简单语言的成本更高。

## 2. Lex 源文件

Lex来源的一般格式为：

```text
                             {definitions}
                             %%
                             {rules}
                             %%
                             {user subroutines}
```

其中通常会省略定义和用户子例程。 第二个%%是可选的，但第一个%%是标记规则开头的必需项。 因此，绝对最小的Lex程序是

```text
                                     %%
```

(没有定义，没有规则)，它转换为一个程序，该程序将输入不变地复制到输出中。

在上面显示的Lex程序的概述中，规则代表用户的控制决策； 它们是一个表，其中的左列包含正则表达式(请参见第3节)，而右列包含动作，识别表达式时要执行的程序片段。 因此，可能会出现一条个人规则

```text
                   integer   printf("found keyword INT");
```

在输入流中查找字符串整数，并在出现时打印消息"found keyword INT"。 在此示例中，宿主过程语言为C，C库函数printf用于打印字符串。 表达式的结尾由第一个空格或制表符表示。 如果动作只是一个C表达式，则可以在该行的右侧给出； 如果它是复合的，或者用不止一行，则应将其括在大括号中。 作为一个稍微有用的示例，假设希望将许多单词从英式拼写改为美式拼写。 Lex规则如下

```text
                      colour      printf("color");
                      mechanise   printf("mechanize");
                      petrol      printf("gas");
```

将是一个开始。 这些规则还不够，因为石油一词会变成天然气。 一种处理方法将在后面描述。

### 3. Lex 正则表达式

正则表达式的定义与QED [5]中的定义非常相似。正则表达式指定一组要匹配的字符串。它包含文本字符(与要比较的字符串中的相应字符匹配)和运算符(指定重复，选择和其他功能)。字母和数字始终是文本字符；因此正则表达式
```text
                                 integer
```
匹配出现的字符串整数和表达式

```text
                                    a57D
```
查找字符串a57D。

### 3.1 运算符

运算符是

```text
                   "\[]^-?.*+|()$/{}%<>
```
如果将它们用作文本字符，则应使用转义符。引号运算符(")表示将一对引号之间包含的任何内容都视为文本字符。

```text
                                   xyz"++”
```

当字符串xyz++出现时与其匹配。请注意，可能会括起字符串的一部分。括起普通文本字符是无害的，但没有必要；表达式

```text
                                   "xyz++"
```

与上面的相同。因此，通过括起被用作文本字符的每个非字母数字字符，用户可以免于记住上面关于当前操作符的那列表，并且可以安全地使用Lex的进一步扩展来加长该列表。

也可以通过在运算符前面加上\来将其转换为文本字符，如

```text
                                   xyz\+\+
```

这是上述表达式的另一种较不易读的等效形式。括起机制的另一种用法是使表达式成为空白。通常，如上所述，空格或制表符结束规则。 [](请参阅下文)中未包含的任何空白字符都必须加引号。可以识别带有\的几个普通C换码符：\n是换行符，\t是制表符，\b是退格键。要输入\本身，请使用\\。由于换行符在表达式中是非法的，因此必须使用\ n；转义制表符和退格键是不被要求的。除空白，制表符，换行符和上面的列表以外的所有字符始终是文本字符。

### 3.2 字符类

字符类是可以使用运算符[]指定的字符类别。结构[abc]与单个字符匹配，可以是a，b或c。在方括号内，大多数运算符的含义都将被忽略。只有三个特殊字符：\\,-和^。 -字符表示范围。例如，

```text
                                 [a-z0-9<>_]
```

指示包含所有小写字母，数字，尖括号和下划线的字符类。范围可以以任何顺序给出。在不是大写字母，小写字母或两位数字的任意一对字符之间使用-是取决于实现的，并且会收到警告消息。 (例如，ASCII中的[0-z]比EBCDIC中的字符多得多)。如果希望在字符类中包含字符-则应在第一个或最后一个字符中；从而

```text
                                   [-+0-9]
```

匹配所有数字和两种符号。
在字符类中，^运算符必须为左括号后的第一个字符；它表示结果字符串将相对于计算机字符集的补集。从而

```text
                                   [^abc]
```
匹配除a，b或c以外的所有字符，包括所有特殊或控制字符；或

```text
                                  [^a-zA-Z]
```

代表不是字母的任何字符。 \字符提供了字符类括号内的常规转义。

### 3.3 任意字符

是为了匹配几乎所有字符和运算符。是除换行符以外的所有字符的类。也可以转义为八进制， 尽管不可移植：

```text
                                 [\40-\176]
```

匹配ASCII字符集中的所有可打印字符，从八进制40(空白)到八进制176(波浪号)。

### 3.4 可选表达式

运算符?表示表达式的可选元素。从而

```text
                                    ab?c
```

匹配ac或abc。

### 3.5 重复的表达式

类的重复由运算符*和+指示。

```text
                                     a*
```

是任意数量的连续字符，包括零；而

```text
                                     a+
```

是a的一个或多个实例。例如，

```text
                                   [a-z]+
```

是所有小写字母的字符串。和

```text
                            [A-Za-z][A-Za-z0-9]*
```

表示所有带有字母字符前缀的字母数字字符串。这是用于识别计算机语言中的标识符的典型表达。

### 3.6 交替和分组

运算符|表示交替：

```text
                                   (ab|cd)
```

匹配ab或cd。请注意，括号是用于分组的，尽管用在最外部是没有必要的。

```text
                                    ab|cd
```

就足够了。括号可用于更复杂的表达式：

```text
                               (ab|cd+)?(ef)*
```

匹配诸如abefef，efefef，cdef或cddd之类的字符串；但不包括abc，abcd或abcdef。

### 3.7 上下文敏感

Lex将识别出少部分的周遭环境。两个最简单的运算符是^和$。如果表达式的第一个字符是^，则仅在行的开头(在换行符之后或在输入流的开头)匹配表达式。这绝不会与^的其他含义(字符类的补集)相冲突，因为补集仅适用于[]运算符内。如果最后一个字符是$，则仅在行尾匹配表达式(当换行符紧随其后)。后一个运算符是/运算符的特殊情况，它表示跟随上下文。表达方式

```text

                                    ab/cd
```

匹配字符串ab，但仅在后面跟cd时匹配。从而

```text
                                     ab$
```

与下式是相同的

```text
                                    ab/\n
```

如第10节中所述，在Lex中通过启动条件来处理左上下文。如果一条规则仅在Lex自动机解释器处于开始条件x时才执行，则该规则应以下方前缀开头

```text
                                     <x>
```

使用尖括号运算符。如果我们认为''在一行的开头''就是开始条件ONE，则^运算符将等效于

```text
                                    <ONE>
```

开始条件将在后面更全面地说明。

### 3.8 重复和定义

运算符{}指定重复(如果包含数字)或定义扩展(如果包含名称)。例如

```text
                                   {digit}
```

查找名为digit的预定义字符串，并将其插入表达式中的使用点。在Lex输入的第一部分中给出了定义，在规则之前。相反，

```text
                                   a{1,5}
```

查找1至5次出现的a。
最后，初始%很特殊，它是Lex源段的分隔符。

## 4. Lex 动作

当上面编写的表达式匹配时，Lex将执行相应的操作。本节描述Lex的一些有助于编写动作的功能。请注意，有一个默认操作，该操作包括将输入复制到输出。此操作会对所有不匹配的字符串执行。因此，希望吸收整个输入而不产生任何输出的Lex用户必须提供匹配所有内容的规则。当Lex与Yacc一起使用时，这是正常情况。人们可能会认为动作是已经完成的，而不是将输入复制到输出。因此，通常可以省略仅进行复制的规则。同样，规则中省略的字符组合也可能作为输入出现在输出上，从而引起对规则之间的缝隙的注意。

可以做的最简单的事情之一就是忽略输入。指定一个C空语句；作为动作会导致此结果。一个常见的规则是

```text
                                 [ \t\n];
```

这将导致三个空白字符(空格，制表符和换行符)被忽略。

避免编写动作的另一种简便方法是动作字符|，它表示该规则的动作是下一个规则的动作。前面的例子也可以写成

```text
                                   " "
                                   "\t"
                                   "\n"
```

尽管样式不同，但效果相同。\n和\t周围的引号不是必需的。

在更复杂的操作中，用户通常会希望知道与某些表达式(如[a-z] +)匹配的实际文本。 Lex将此文本留在名为yytext的外部字符数组中。因此，要打印找到的名称，规则如下

```text
                       [a-z]+	printf("%s", yytext);
```

将以yytext打印字符串。 C函数printf接受格式参数和要打印的数据。在这种情况下，格式为''打印字符串''(%表示数据转换，s表示字符串类型)，数据为yytext中的字符。因此，这只是将匹配的字符串放在输出上。此操作非常常见，可以写为ECHO：

```text
                               [a-z]+	ECHO;
```

与上述相同。由于默认操作只是打印找到的字符，因此有人可能会问为什么要给出这样的规则，使该规则仅指定默认操作？通常需要这样的规则来避免匹配一些其他不需要的规则。例如，如果存在与读取匹配的规则，则通常将匹配面包或重新调整中包含的读取实例；为了避免这种情况，需要使用[a-z] +形式的规则。这将在下面进一步说明。

有时，更容易知道发现的结果。因此，Lex还提供了匹配字符数的计数。为了同时计算输入中的单词数和单词中的字符数，用户可以写[a-zA-Z] + {words ++; chars + = yyleng;}，它在chars中累积识别出的单词中的字符数。匹配字符串中的最后一个字符可以通过下列方式访问

```text

                              yytext[yyleng-1]
```

有时，Lex动作可能会确定规则未识别正确范围的字符。Lex提供了两个例程来辅助这种情况。首先，可以调用yymore()来指示将下一个识别出的输入表达式附加到该输入的末尾。通常，下一个输入字符串将覆盖yytext中的当前条目。其次，可以调用yyless(n)来指示当前并非需要所有与当下成功的表达式匹配的字符。参数n表示yytext中要保留的字符数。先前匹配的其他字符将返回到输入。这提供了/运算符提供的相同类型的向前看功能，但是形式不同。

示例：考虑一种语言，该语言将字符串定义为引号(")之间的一组字符，并规定如果要在字符串中包含"，必须在其前面加上\。与其匹配的正则表达式有些令人困惑，因此最好编写如下形式

```text
                  \"[^"]*   {
                            if (yytext[yyleng-1] == '\\')
                                 yymore();
                            else
                                 ... normal user processing
                            }
```

当遇到诸如"abc\"def之类的字符串时，它将首先与五个字符"abc \匹配；那么对yymore()的调用将导致字符串的下一部分" def"被添加到末尾。请注意，终止该字符串的最后引号应在标有"normal processing”的代码中挑出。

函数yyless()可能会在各种情况下用于重新处理文本。考虑关于区分''= -a''的歧义的C问题。假设希望将此语句视为''=-a''但打印一条消息。一条规则可能是

```text
                 =-[a-zA-Z] {
                              printf(" Op(=-) ambiguous\n");
                              yyless(yyleng-1);
                               ... action for =- ...
                              }
```

它会打印一条消息，将运算符后的字母返回到输入流，并将运算符视为``=-''。或者，可能需要将此视为''= -a''。为此，只需返回减号以及输入的字母：

```text
                 =-[a-zA-Z] {
                              printf(" Op(=-) ambiguous\n");
                              yyless(yyleng-2);
                              ... action for = ...
                              }
```

将执行其他解释。请注意，这两种情况的表达式可能更容易编写

```text
                               =-/[A-Za-z]
```

在第一种情况下，

```text
                                 =/-[A-Za-z]
```

第二，规则动作中不需要备份。不必识别整个标识符来观察歧义现象。但是，出现''= -3''的可能性使

```text
                                 =-/[^\t\n]
```

成为更好的规则。

除这些例程外，Lex还允许访问其使用的I/O例程。他们是：

1)input()返回下一个输入字符；

2)output(c)将字符c写入输出；和

3)unput(c)将字符c推回输入流，以便稍后由input()读取。

默认情况下，这些例程是作为宏定义提供的，但是用户可以覆盖它们并提供私有版本。这些例程定义了外部文件和内部字符之间的关系，并且它们必须整体保留或修改。它们被可以重新定义，以使输入或输出被传送到陌生的地方，包括其他程序或内部存储器；但是使用的字符集在所有例程中必须一致；输入返回的零值必须表示文件结尾；并且必须保留unput和输入之间的关系，否则Lex lookahead将无法正常工作。 Lex不会向前看，如果不是必要的话，但是每条以+ * ?或$结尾或包含/的规则意味着向前看。匹配另一个表达式的前缀的表达式也需要向前看。有关Lex使用的字符集的讨论，请参见下文。标准Lex库对备份施加了100个字符的限制。

用户有时想要重新定义的另一个Lex库例程是yywrap()，只要Lex到达文件末尾，就会调用该例程。如果yywrap返回1，则Lex在输入结束时继续进行常规包装。但是，有时候，为更多的输入从新的源进行安排会很方便。在这种情况下，用户应提供一个yywrap，它安排新的输入并返回0。这指示Lex继续进行处理。默认的yywrap总是返回1。

该例程也是一个方便的打印表，摘要等信息的位置——在程序的末尾。注意，不可能编写识别文件结尾eof的普通规则；唯一访问此条件的方法是通过yywrap。实际上，除非提供了input()的私有版本，否则无法处理包含null的文件，因为input返回的值为0被视为文件结尾。

## 5. 模糊源规则

Lex可以处理模糊的规范。当多个表达式可以匹配当前输入时，Lex作出如下选择：

1. 最长的匹配为佳。

2. 在匹配相同字符数的规则中，首选先给出的规则。

因此，假设规则

```text
                      integer   keyword action ...;
                      [a-z]+    identifier action ...;
```

以该顺序给出。如果输入是integers，则将其视为标识符，因为[a-z] +匹配8个字符，而整数仅匹配7。如果输入是integer，则两个规则都匹配7个字符，并且kwyword action规则会被选择，因为它是第一个给定的。较短的任何内容(例如int)都不会与integer表达式匹配，因此将使用标识符解释。

首选最长匹配的原则会使包含.*之类的表达式的规则变得危险。例如，'.*'似乎是识别单引号中的字符串的一种好方法。但这对程序是个邀请，会遥远地向前看并寻找遥远的单引号。通过输入呈现：

```text
                'first' quoted string here, 'second' here
```

上面的表达式将匹配

```text
                   'first' quoted string here, 'second'
```
这可能不是想要的。更好的规则是

```text
                                  '[^'\n]*'
```

在上面的输入中，它将在'first'之后停止。此类错误的后果可以通过以下事实得到缓解：运算符将不匹配换行符。因此，.*之类的表达式在当前行停止。不要试图用类似(.|\n)+或等价的表达式来扳倒它； Lex生成的程序将尝试读取整个输入文件，从而导致内部缓冲区溢出。

请注意，Lex通常在对输入流进行分区，而不是搜索每个表达式的所有可能匹配项。这意味着每个字符仅被计入一次。例如，假设希望对输入文本中she和he的出现进行计数。一些Lex的规则可能是

```text
                                 she   s++;
                                 he    h++;
                                 \n    |
                                 .     ;
```

最后两个规则忽略了he和she以外的所有事物。记住.不包括换行符。由于she包括he，所以Lex通常不会识别he包括在she中的实例，因为一旦通过了she，这些字符就消失了。

有时，用户希望覆盖此选择。动作REJECT的意思是''去做下一个选择''。它将导致执行当前规则之后第二选择的规则。输入指针的位置会进行相应的调整。假设用户确实要计算包含he的实例：
```text
                            she   {s++; REJECT;}
                            he    {h++; REJECT;}
                            \n    |
                            .     ;
```
这些规则是更改前面的示例来做到这一点的一种方法。计算完每个表达式后，将其拒绝；只要合适，其他表达式将被计算。当然，在此示例中，用户可以注意到she包括he，但反之则不包括，并且忽略了对he的REJECT动作；但是，在其他情况下，不可能先验地确定两个类中都包含哪些输入字符。
考虑两个规则

```text
                          a[bc]+   { ... ; REJECT;}
                          a[cd]+   { ... ; REJECT;}
```
如果输入为ab，则仅第一个规则匹配，而在ad上仅第二个匹配。输入字符串accb与第一个规则匹配四个字符，然后第二个规则匹配三个字符。相反，输入accd使第二个规则匹配四个字符，然后第一个规则匹配3个字符。

通常，只要Lex的目的不是分割输入流而是检测输入中某些项的所有示例，而这些项目的实例可能重叠或彼此包含，则REJECT很有用。假设需要输入的Digram表；通常，二元图重叠，也就是说，单词the被认为同时包含th和he。假设一个名为digram的二维数组要递增，则适当的源为

```text
                %%
                [a-z][a-z]   {
                             digram[yytext[0]][yytext[1]]++;
                             REJECT;
                             }
                .            ;
                \n           ;
```

需要拒绝才能从每个字符而不是每个其他字符处开始的字母对。

## 6. Lex 源定义

记住Lex源代码的格式：

```text
                               {definitions}
                               %%
                               {rules}
                               %%
                               {user routines}
```

到目前为止，仅描述了规则。但是，用户需要其他选项来定义要在其程序中使用以及供Lex使用的变量。这些可以在"定义"部分或"规则"部分中进行。
请记住，Lex正在将规则变成程序。未被Lex拦截的任何源都将复制到生成的程序中。这样的东西分为三类。

1. 任何不属于Lex规则或操作的行(以空格或制表符开头)都将被复制到Lex生成的程序中。第一个%%分隔符之前的此类源输入将落在代码中的任何函数外部；如果它出现在第一个%%之后，则它出现在Lex编写的包含操作的函数中的对声明适当的位置。这些材料必须看起来像程序片段，并且应该在第一个Lex规则之前。作为上述方法的副作用，将以空白或制表符开头并包含注释的行传递到生成的程序。这可用于在Lex源或生成的代码中包含注释。注释应遵循宿主语言约定。

2. 任何包含在%{和%}行之间的所有内容均像上述方式复制出来。分隔符将被丢弃。这种格式允许输入像预处理器语句这样的文本，它们必须在第1列开始，或者是复制看起来不像程序的行。

3. 在第三个%%分隔符之后的所有内容，无论格式如何，都将在Lex输出之后复制出来。

用于Lex的定义在第一个%%分隔符之前给出。该部分中任何不包含在%{和%}之间且从第1列开始的行均被定义为Lex替换字符串。这种行的格式是名称转换，它会使作为转换给出的字符串与名称相关联。名称和翻译必须至少用一个空格或制表符分隔，并且名称必须以字母开头。然后可以在规则中使用{name}语法来调出翻译。例如，对数字使用{D}，对指数字段使用{E}，可能会简化识别数字的规则：

```text
                   D                   [0-9]
                   E                   [DEde][-+]?{D}+
                   %%
                   {D}+                printf("integer");
                   {D}+"."{D}*({E})?   |
                   {D}*"."{D}+({E})?   |
                   {D}+{E}
```

注意实数的前两个规则； 两者都需要一个小数点并且包含一个可选的指数字段，但是第一个要求在小数点之前至少一位数字，第二个要求在小数点之后至少一位数字。 为了正确处理由Fortran表达式(例如35.EQ.I)引起的问题，该表达式不包含实数，请使用上下文相关的规则，例如

```text
                      [0-9]+/"."EQ   printf("integer");
```

除了通常的整数规则外，还可以使用。

定义部分还可以包含其他命令，包括选择宿主语言，字符集表，开始条件列表，或对大型源程序在Lex自身中对数组默认大小的调整。 这些可能性在下面的``源格式概述''第12节中讨论。

## 7. 使用

编译Lex源程序有两个步骤。首先，必须将Lex源代码转换为使用宿主通用语言生成的程序。然后，必须使用Lex子例程库来编译和加载该程序。生成的程序在名为lex.yy.c的文件上。 I/ O库是根据C标准库定义的[6]。

Lex生成的C程序在OS/370上略有不同，因为OS编译器的不如UNIX或GCOS编译器强力，并且在编译时也做较少的工作。在GCOS和UNIX上生成的C程序是相同的。

UNIX。该库可通过装入程序标志-ll访问。因此，合适的命令集是lex source cc lex.yy.c -ll。结果程序放在通常的文件a.out上，以便以后执行。要将Lex与Yacc一起使用，请参见下文。尽管默认的Lex I/O例程使用C标准库，但是Lex自动机本身并不使用C标准库。如果给出了输入，输出和输入的私有版本，则可以避免使用该库。

## 8. Lex 和 Yacc

如果要将Lex与Yacc一起使用，请注意Lex编写的是一个名为yylex()的程序，该程序是Yacc所需的供其分析器使用的名称。通常，Lex库上的默认主程序会调用此例程，但是如果加载了Yacc，并且使用了其主程序，则Yacc将调用yylex()。在这种情况下，每个Lex规则都应以结尾

```text
                               return(token);
```

返回适当的令牌值的位置。访问令牌的Yacc名称的一种简单方法是，通过在Yacc输入的最后一部分放置#include"lex.yy.c"行，将Lex输出文件编译为Yacc输出文件的一部分。假设将语法命名为''good''，将词汇规则命名为''better''，则UNIX命令序列可以是：

```text
                             yacc good
                             lex better
                             cc y.tab.c -ly -ll
```

Yacc库(-ly)应该在Lex库之前加载，以获取调用Yacc解析器的主程序。 Lex和Yacc程序的生成可以按照任何顺序进行。

## 9. 样例

作为一个小问题，请考虑在复制输入文件的同时，将每个3乘以7的正数加3。这是一个合适的Lex源程序

```text
                      %%
                               int k;
                      [0-9]+   {
                               k = atoi(yytext);
                               if (k%7 == 0)
                                    printf("%d", k+3);
                               else
                                    printf("%d",k);
                               }
```

做到这一点。规则[0-9] +识别数字字符串； atoi将数字转换为二进制并将结果存储在k中。运算符%(余数)用于检查k是否可被7除。如果是，则在写入时将其增加3。可能会被反对，因为                                                                                                                                       该程序将更改诸如49.63或X7之类的输入项。此外，它会将所有可被7整除的负数的绝对值增加。为避免这种情况，只需在活动规则之后添加一些规则，如下所示：

```text
                %%
                                       int k;
                -?[0-9]+               {
                                       k = atoi(yytext);
                                       printf("%d",
                                         k%7 == 0 ? k+3 : k);
                                       }
                -?[0-9.]+              ECHO;
                [A-Za-z][A-Za-z0-9]+   ECHO;
```

包含''.''或字母开头的数字字符串将由后两个规则之一选择，并且不会更改。 if-else已替换为C条件表达式，以节省空间；形式a?b:c的意思是''如果a然后b否则c''。
对于统计信息收集的示例，这是一个对单词长度进行直方图分析的程序，其中单词被定义为字母字符串。

```text
                           int lengs[100];
                  %%
                  [a-z]+   lengs[yyleng]++;
                  .        |
                  \n       ;
                  %%
                  yywrap()
                  {
                  int i;
                  printf("Length  No. words\n");
                  for(i=0; i<100; i++)
                       if (lengs[i] > 0)
                            printf("%5d%10d\n",i,lengs[i]);
                  return(1);
                  }
```

该程序累积直方图，并不产生任何输出。在输入的末尾，它将打印表格。最后的语句return(1);指示Lex将执行包装。如果yywrap返回零(假)，则意味着进一步的输入可用，并且程序将继续读取和处理。提供永不返回true的yywrap会导致无限循环。

作为更大的示例，这是N. L. Schryer编写的将双精度Fortran转换为单精度Fortran的程序的某些部分。因为Fortran不能区分大小写字母，所以此例程首先定义一组类，包括每个字母的两种情况：

```text
                                 a     [aA]
                                 b     [bB]
                                 c     [cC]
                                 ...
                                 z     [zZ]
```

另一个类可以识别空格：

```text
                                 W [ \t]*
```

第一个规则将''double precision''更改为''real''，或将''DOUBLE PRECISION''更改为``REAL''。

```text
             {d}{o}{u}{b}{l}{e}{W}{p}{r}{e}{c}{i}{s}{i}{o}{n} {
                  printf(yytext[0]=='d'? "real" : "REAL");
                  }
```

在整个程序中要格外小心，以保留原始程序的大小写(大写或小写)。条件运算符用于选择关键字的正确形式。下一条规则复制延续卡指示，以避免将它们与常量混淆：

```text
                            ^"     "[^ 0]   ECHO;
```

在正则表达式中，引号引起来。它被解释为"行的开头，然后是五个空格，然后是空白或零以外的任何东西."请注意^的两种不同含义。遵循一些规则将双精度常量更改为普通浮点常量。

```text
                  [0-9]+{W}{d}{W}[+-]?{W}[0-9]+     |
                  [0-9]+{W}"."{W}{d}{W}[+-]?{W}[0-9]+     |
                  "."{W}[0-9]+{W}{d}{W}[+-]?{W}[0-9]+     {
                       /* convert constants */
                       for(p=yytext; *p != 0; p++)
                            {
                            if (*p == 'd' || *p == 'D')
                                 *p=+ 'e'- 'd';
                            ECHO;
                            }
```

识别出浮点常量后，将通过for循环对其进行扫描以找到字母d或D。然后，该程序将添加"e"-" d"，将其转换为字母的下一个字母。修改后的常数(现在是单精度)再次被写出。紧随其后的是一系列名称，必须删除它们的首字母d。通过使用数组yytext，所有名称都可以执行相同的操作(此处仅给出了一个较长列表的示例)。

```text
                 {d}{s}{i}{n}         |
                 {d}{c}{o}{s}         |
                 {d}{s}{q}{r}{t}      |
                 {d}{a}{t}{a}{n}      |
                 ...
                 {d}{f}{l}{o}{a}{t}   printf("%s",yytext+1);
```

另一个名称列表必须将首字母d更改为首字母a：
                  {d}{l}{o}{g}     |
                  {d}{l}{o}{g}10   |
                  {d}{m}{i}{n}1    |
                  {d}{m}{a}{x}1    {
                                   yytext[0] =+ 'a' - 'd';
                                   ECHO;
                                   }
并且一个例程必须将初始d更改为初始r：

```text
                {d}1{m}{a}{c}{h}   {yytext[0] =+ 'r'  - 'd';
```

为了避免将诸如dsinx之类的名称检测为dsin的实例，一些最终规则会采用更长的单词作为标识符并复制一些尚存的字符：

```text
                        [A-Za-z][A-Za-z0-9]*   |
                        [0-9]+                 |
                        \n                     |
                        .                      ECHO;
```
						
请注意，该程序尚未完成。它不处理Fortran中的间距问题，也不使用关键字作为标识符。

## 10. 左上下文敏感

有时，需要在输入中的不同时间应用几组词汇规则。例如，编译器预处理器可能会区分预处理器语句，并与普通语句进行不同的分析。这就要求对先验背景敏感，并且有几种方法可以解决这些问题。例如，^运算符是先验上下文运算符，识别紧接在左上下文之前的内容，就像$识别紧接在右上下文之后的内容一样。可以扩展相邻的左上下文，以产生类似于相邻右上下文的功能，但这种功能不太可能有用，因为相关的左上下文通常在更早的时间出现，例如在一行的开头。

本节描述了处理不同环境的三种方法：标志的简单使用，当只有几个规则从一个环境更改为另一个环境时，规则开始条件的使用，以及使多个词法分析器一起运行的可能性。在每种情况下，都有一些规则可以识别关于更改分析之后的输入文本的环境和一些反映更改的参数，的需要的规则。这可能是由用户的动作代码明确测试的标志；因为Lex根本不参与，所以这样的标记是解决问题的最简单方法。但是，让Lex记住标志作为规则的初始条件可能更方便。任何规则都可以与开始条件相关联。仅当Lex处于该启动状态时，它才会被识别。当前启动条件可以随时更改。最后，如果不同环境的规则集非常不同，则可以通过编写几个不同的词法分析器并根据需要从一个切换到另一个以最好地实现清晰性。

考虑以下问题：将输入复制到输出，将以单词a开头的每一行上的魔术单词更改为第一位，以字母b开头的每一行将魔术更改为第二位，并将以字母c开头的每行的魔术单词更改为第三位，所有其他单词和所有其他行均保持不变。

这些规则是如此简单，以至于最简单的方法是使用标志：

```text
                         int flag;
                 %%
                 ^a      {flag = 'a'; ECHO;}
                 ^b      {flag = 'b'; ECHO;}
                 ^c      {flag = 'c'; ECHO;}
                 \n      {flag =  0 ; ECHO;}
                 magic   {
                         switch (flag)
                         {
                         case 'a': printf("first"); break;
                         case 'b': printf("second"); break;
                         case 'c': printf("third"); break;
                         default: ECHO; break;
                         }
                         }
```

应该足够了。

要处理开始条件的相同问题，必须在定义部分中将每个开始条件引入到Lex中，并在其中加上一行

```text
                          %Start   name1 name2 ...
```
						  
条件可以以任何顺序命名。单词Start可以缩写为s或S。可以在规则的开头使用<>括号引用条件：

```text
                              <name1>expression
```

是仅当Lex处于开始条件name1中时才能识别的规则。要输入开始条件，请执行动作语句

```text
                                BEGIN name1;
```

它将开始条件更改为name1。要恢复正常状态，

```text
                                  BEGIN 0;
```

重置Lex自动机解释器的初始条件。规则可能在多个开始条件中处于活动状态：<name1，name2，name3>是合法前缀。任何不以<>前缀运算符开头的规则始终处于活动状态。

可以编写与之前相同的示例：

```text
                     %START AA BB CC
                     %%
                     ^a                {ECHO; BEGIN AA;}
                     ^b                {ECHO; BEGIN BB;}
                     ^c                {ECHO; BEGIN CC;}
                     \n                {ECHO; BEGIN 0;}
                     <AA>magic         printf("first");
                     <BB>magic         printf("second");
                     <CC>magic         printf("third");
```

逻辑与前面解决问题的方法完全相同，但是Lex负责工作而不是用户代码。

## 11. 字符集

Lex生成的程序仅通过例程的输入，输出和输出来处理字符I/O。因此，这些例程中提供的字符表示被Lex接受，并用于返回yytext中的值。对于内部使用，字符表示为小整数，如果使用标准库，则其值等于主机上代表字符的位模式的整数值。通常，字母a表示为与字符常量"a"相同的形式。如果更改了这种解释，则通过提供翻译字符的I/O例程，必须通过提供翻译表来告知Lex。该表必须在''定义''部分中，并且必须用仅包含''%T''的行括起来。该表包含以下形式的行

```text
                        {integer} {character string}
```

指示与每个字符关联的值。因此，下一个例子

```text
                                  %T
                                   1    Aa
                                   2    Bb
                                  ...
                                  26    Zz
                                  27    \n
                                  28    +
                                  29    -
                                  30    0
                                  31    1
                                  ...
                                  39    9
                                  %T

                           Sample character table.
```						   

将小写和大写字母映射到整数1到26，换行符映射到27，+和-映射到28和29，数字映射到30到39。请注意换行符。如果提供了表格，则规则中或任何有效输入中将出现的每个字符都必须包括在表格中。不能给字符分配数字0，也不能给任何字符分配大于硬件字符集大小的数字。


## 12. 源文件格式总结

Lex源文件的一般形式为：

```text
                             {definitions}
                             %%
                             {rules}
                             %%
                             {user subroutines}
```

定义部分包含以下内容的组合  

1)定义，形式为''名称空间翻译''。

2)包含的代码，形式为''空间代码''。

3)包含的代码，形式为

```text
                                       %{
                                       code
                                       %}
```

4)开始条件，以表格形式给出

```text
                                %S name1 name2 ...
```

5)字符集表，形式为

```text
                          %T
                          number space character-string
                          ...
                          %T
```

6)更改内部数组大小，形式为

```text
                                     %x  nnn
```

其中nnn是代表数组大小的十进制整数，并且x按如下所示选择参数：

```text
                        Letter          Parameter
                          p      positions
                          n      states
                          e      tree nodes
                          a      transitions
                          k      packed character classes
                          o      output array size
```

规则部分中的行具有；；表达式动作''的形式，该动作可以通过使用大括号定界在后续行上继续执行。
Lex中的正则表达式使用以下运算符：

```text
               x        the character "x"
               "x"      an "x", even if x is an operator.
               \x       an "x", even if x is an operator.
               [xy]     the character x or y.
               [x-z]    the characters x, y or z.
               [^x]     any character but x.
               .        any character but newline.
               ^x       an x at the beginning of a line.
               <y>x     an x when Lex is in start condition y.
               x$       an x at the end of a line.
               x?       an optional x.
               x*       0,1,2, ... instances of x.
               x+       1,2,3, ... instances of x.
               x|y      an x or a y.
               (x)      an x.
               x/y      an x but only if followed by y.
               {xx}     the translation of xx from the
                        definitions section.
               x{m,n}   m through n occurrences of x
```

## 13. 注意事项和错误。

当转换为确定性机器时，有些不正常的表达式会导致表格的指数增长。 幸运的是，它们很少见。

REJECT不会重新扫描输入。 相反，它会记住上一次扫描的结果。 这意味着，如果找到具有尾随上下文的规则并执行了REJECT，则用户一定不能使用unput来更改输入流中即将出现的字符。 这是对用户操纵尚未处理的输入的能力的唯一限制。

## 14. 错误恢复

The basic requirement for the compiler is to simply stop and issue a message, and cease compilation. There are some common recovery methods that are follows.

1. Panic mode recovery: This is the easiest way of error-recovery and also, it prevents the parser from developing infinite loops while recovering error. The parser discards the input symbol one at a time until one of the designated (like end, semicolon) set of synchronizing tokens (are typically the statement or expression terminators) is found. This is adequate when the presence of multiple errors in same statement is rare. Example: Consider the erroneous expression- (1 + + 2) + 3. Panic-mode recovery: Skip ahead to next integer and then continue. Bison: use the special terminal error to describe how much input to skip.
E->int|E+E|(E)|error int|(error) 
2. Phase level recovery: Perform local correction on the input to repair the error. But error correction is difficult in this strategy.
3. Error productions: Some common errors are known to the compiler designers that may occur in the code. Augmented grammars can also be used, as productions that generate erroneous constructs when these errors are encountered. Example: write 5x instead of 5*x
4. Global correction: Its aim is to make as few changes as possible while converting an incorrect input string to a valid string. This strategy is costly to implement.

## 15. 致谢

从上面可以明显看出，Lex的外部在Yacc上被模式化，而Aho的字符串匹配例程在内部。 因此，S。C. Johnson和A. V. Aho都是Lex的创始人，也是Lex的调试者。 非常感谢。

当前版本的Lex的代码是由Eric Schmidt设计，编写和调试的。

## 16. 参考

1. B. W. Kernighan and D. M. Ritchie, The C Programming Language, Prentice-Hall, N. J. (1978).

2. B. W. Kernighan, Ratfor: A Preprocessor for a Rational Fortran, Software Practice and Experience, 5, pp. 395-496 (1975).

3. S. C. Johnson, Yacc: Yet Another Compiler Compiler, Computing Science Technical Report No. 32, 1975, Bell Laboratories, Murray Hill, NJ 07974.

4. A. V. Aho and M. J. Corasick, Efficient String Matching: An Aid to Bibliographic Search, Comm. ACM 18, 333-340 (1975).

5. B. W. Kernighan, D. M. Ritchie and K. L. Thompson, QED Text Editor, Computing Science Technical Report No. 5, 1972, Bell Laboratories, Murray Hill, NJ 07974.

6. D. M. Ritchie, private communication. See also M. E. Lesk, The Portable C Library, Computing Science Technical Report No. 31, Bell Laboratories, Murray Hill, NJ 07974.

